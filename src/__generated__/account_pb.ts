// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=.ts"
// @generated from file account.proto (package account, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Struct, Timestamp } from "@bufbuild/protobuf";
import { QueryMethod } from "./items_pb.ts";

/**
 * @generated from enum account.SourceStatus
 */
export enum SourceStatus {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * The source is starting or updating. This is only applicable to managed
   * sources where Overmind manages the source's lifecycle
   *
   * @generated from enum value: STATUS_PROGRESSING = 1;
   */
  STATUS_PROGRESSING = 1,

  /**
   * The source is healthy
   *
   * @generated from enum value: STATUS_HEALTHY = 2;
   */
  STATUS_HEALTHY = 2,

  /**
   * The source is unhealthy
   *
   * @generated from enum value: STATUS_UNHEALTHY = 3;
   */
  STATUS_UNHEALTHY = 3,

  /**
   * The source is sleeping due to inactivity. It will be woken up before it
   * is needed. This is only applicable to managed sources where Overmind
   * manages the source's lifecycle
   *
   * @generated from enum value: STATUS_SLEEPING = 4;
   */
  STATUS_SLEEPING = 4,

  /**
   * The source is disconnected and therefore not able to handle requests.
   * This will only be returned for non-managed sources that have recently
   * stopped sending heartbeats such as a user running the CLI that has
   * recently disconnected
   *
   * @generated from enum value: STATUS_DISCONNECTED = 5;
   */
  STATUS_DISCONNECTED = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(SourceStatus)
proto3.util.setEnumType(SourceStatus, "account.SourceStatus", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_PROGRESSING" },
  { no: 2, name: "STATUS_HEALTHY" },
  { no: 3, name: "STATUS_UNHEALTHY" },
  { no: 4, name: "STATUS_SLEEPING" },
  { no: 5, name: "STATUS_DISCONNECTED" },
]);

/**
 * Whether the source is managed by srcman or was created by the user locally
 *
 * @generated from enum account.SourceManaged
 */
export enum SourceManaged {
  /**
   * Local is the default
   *
   * @generated from enum value: LOCAL = 0;
   */
  LOCAL = 0,

  /**
   * @generated from enum value: MANAGED = 1;
   */
  MANAGED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(SourceManaged)
proto3.util.setEnumType(SourceManaged, "account.SourceManaged", [
  { no: 0, name: "LOCAL" },
  { no: 1, name: "MANAGED" },
]);

/**
 * @generated from enum account.AdapterCategory
 */
export enum AdapterCategory {
  /**
   * Fall-back category for resources that do not fit into any other category
   *
   * @generated from enum value: ADAPTER_CATEGORY_OTHER = 0;
   */
  OTHER = 0,

  /**
   * This category includes resources that provide processing power and host
   * applications or services. Examples are virtual machines, containers,
   * serverless functions, and application hosting platforms. If the primary
   * purpose of a resource is to execute workloads, run code, or host
   * applications, it should belong here.
   *
   * @generated from enum value: ADAPTER_CATEGORY_COMPUTE_APPLICATION = 1;
   */
  COMPUTE_APPLICATION = 1,

  /**
   * Encompassing resources designed to store, archive, and manage data, this
   * category includes object storage, block storage, file storage, and data
   * backup solutions. Select this category when the core function of a
   * resource is persistent data storage or management
   *
   * @generated from enum value: ADAPTER_CATEGORY_STORAGE = 2;
   */
  STORAGE = 2,

  /**
   * This category covers resources that facilitate connectivity and
   * communication within cloud environments. Typical resources include
   * virtual networks, load balancers, VPNs, and DNS services. Assign
   * resources here if their primary role is related to communication,
   * connectivity, or traffic management
   *
   * @generated from enum value: ADAPTER_CATEGORY_NETWORK = 3;
   */
  NETWORK = 3,

  /**
   * Resources in this category focus on safeguarding data, applications, and
   * cloud infrastructure. Examples include firewalls, identity and access
   * management, encryption services, and security monitoring tools. Choose
   * this category if a resource's main function is security, access control,
   * or compliance
   *
   * @generated from enum value: ADAPTER_CATEGORY_SECURITY = 4;
   */
  SECURITY = 4,

  /**
   * This category includes resources aimed at monitoring, tracing, and
   * logging applications and cloud infrastructure. Examples are monitoring
   * tools, logging services, and performance management solutions. Use this
   * category for resources that provide insights into system performance and
   * health
   *
   * @generated from enum value: ADAPTER_CATEGORY_OBSERVABILITY = 5;
   */
  OBSERVABILITY = 5,

  /**
   * Focused on structured data storage and management, this category includes
   * relational, NoSQL, and in-memory databases, along with data warehousing
   * solutions. Choose this category for resources specifically designed for
   * data querying, transaction processing, or complex data operations. This
   * differs from "storage" in that "databases" have compute associated with
   * them rather than just storing data.
   *
   * @generated from enum value: ADAPTER_CATEGORY_DATABASE = 6;
   */
  DATABASE = 6,

  /**
   * This category includes resources designed for managing configurations and
   * deployments. Examples are infrastructure as code tools, configuration
   * management services, and deployment orchestration solutions. Classify
   * resources here if they primarily handle configuration, environment
   * management, or automated deployment
   *
   * @generated from enum value: ADAPTER_CATEGORY_CONFIGURATION = 7;
   */
  CONFIGURATION = 7,

  /**
   * This category is dedicated to resources for developing, training, and
   * deploying artificial intelligence models and machine learning
   * applications. Include machine learning platforms, AI services, and data
   * labeling tools here. Select this category if a resource's principal
   * function involves AI or machine learning processes
   *
   * @generated from enum value: ADAPTER_CATEGORY_AI = 8;
   */
  AI = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(AdapterCategory)
proto3.util.setEnumType(AdapterCategory, "account.AdapterCategory", [
  { no: 0, name: "ADAPTER_CATEGORY_OTHER" },
  { no: 1, name: "ADAPTER_CATEGORY_COMPUTE_APPLICATION" },
  { no: 2, name: "ADAPTER_CATEGORY_STORAGE" },
  { no: 3, name: "ADAPTER_CATEGORY_NETWORK" },
  { no: 4, name: "ADAPTER_CATEGORY_SECURITY" },
  { no: 5, name: "ADAPTER_CATEGORY_OBSERVABILITY" },
  { no: 6, name: "ADAPTER_CATEGORY_DATABASE" },
  { no: 7, name: "ADAPTER_CATEGORY_CONFIGURATION" },
  { no: 8, name: "ADAPTER_CATEGORY_AI" },
]);

/**
 * @generated from message account.ListAccountsRequest
 */
export class ListAccountsRequest extends Message<ListAccountsRequest> {
  constructor(data?: PartialMessage<ListAccountsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.ListAccountsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccountsRequest {
    return new ListAccountsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccountsRequest {
    return new ListAccountsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccountsRequest {
    return new ListAccountsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccountsRequest | PlainMessage<ListAccountsRequest> | undefined, b: ListAccountsRequest | PlainMessage<ListAccountsRequest> | undefined): boolean {
    return proto3.util.equals(ListAccountsRequest, a, b);
  }
}

/**
 * @generated from message account.ListAccountsResponse
 */
export class ListAccountsResponse extends Message<ListAccountsResponse> {
  /**
   * @generated from field: repeated account.Account accounts = 1;
   */
  accounts: Account[] = [];

  constructor(data?: PartialMessage<ListAccountsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.ListAccountsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "accounts", kind: "message", T: Account, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccountsResponse {
    return new ListAccountsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccountsResponse {
    return new ListAccountsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccountsResponse {
    return new ListAccountsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccountsResponse | PlainMessage<ListAccountsResponse> | undefined, b: ListAccountsResponse | PlainMessage<ListAccountsResponse> | undefined): boolean {
    return proto3.util.equals(ListAccountsResponse, a, b);
  }
}

/**
 * @generated from message account.CreateAccountRequest
 */
export class CreateAccountRequest extends Message<CreateAccountRequest> {
  /**
   * @generated from field: account.AccountProperties properties = 1;
   */
  properties?: AccountProperties;

  constructor(data?: PartialMessage<CreateAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.CreateAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "properties", kind: "message", T: AccountProperties },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAccountRequest {
    return new CreateAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAccountRequest {
    return new CreateAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAccountRequest {
    return new CreateAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAccountRequest | PlainMessage<CreateAccountRequest> | undefined, b: CreateAccountRequest | PlainMessage<CreateAccountRequest> | undefined): boolean {
    return proto3.util.equals(CreateAccountRequest, a, b);
  }
}

/**
 * @generated from message account.CreateAccountResponse
 */
export class CreateAccountResponse extends Message<CreateAccountResponse> {
  /**
   * @generated from field: account.Account account = 1;
   */
  account?: Account;

  constructor(data?: PartialMessage<CreateAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.CreateAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "message", T: Account },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAccountResponse {
    return new CreateAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAccountResponse {
    return new CreateAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAccountResponse {
    return new CreateAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAccountResponse | PlainMessage<CreateAccountResponse> | undefined, b: CreateAccountResponse | PlainMessage<CreateAccountResponse> | undefined): boolean {
    return proto3.util.equals(CreateAccountResponse, a, b);
  }
}

/**
 * @generated from message account.UpdateAccountRequest
 */
export class UpdateAccountRequest extends Message<UpdateAccountRequest> {
  /**
   * @generated from field: account.AccountProperties properties = 1;
   */
  properties?: AccountProperties;

  constructor(data?: PartialMessage<UpdateAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.UpdateAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "properties", kind: "message", T: AccountProperties },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateAccountRequest {
    return new UpdateAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateAccountRequest {
    return new UpdateAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateAccountRequest {
    return new UpdateAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateAccountRequest | PlainMessage<UpdateAccountRequest> | undefined, b: UpdateAccountRequest | PlainMessage<UpdateAccountRequest> | undefined): boolean {
    return proto3.util.equals(UpdateAccountRequest, a, b);
  }
}

/**
 * @generated from message account.UpdateAccountResponse
 */
export class UpdateAccountResponse extends Message<UpdateAccountResponse> {
  /**
   * @generated from field: account.Account account = 1;
   */
  account?: Account;

  constructor(data?: PartialMessage<UpdateAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.UpdateAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "message", T: Account },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateAccountResponse {
    return new UpdateAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateAccountResponse {
    return new UpdateAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateAccountResponse {
    return new UpdateAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateAccountResponse | PlainMessage<UpdateAccountResponse> | undefined, b: UpdateAccountResponse | PlainMessage<UpdateAccountResponse> | undefined): boolean {
    return proto3.util.equals(UpdateAccountResponse, a, b);
  }
}

/**
 * @generated from message account.AdminUpdateAccountRequest
 */
export class AdminUpdateAccountRequest extends Message<AdminUpdateAccountRequest> {
  /**
   * The name of the account to update
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: account.UpdateAccountRequest request = 2;
   */
  request?: UpdateAccountRequest;

  constructor(data?: PartialMessage<AdminUpdateAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdminUpdateAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "request", kind: "message", T: UpdateAccountRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminUpdateAccountRequest {
    return new AdminUpdateAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminUpdateAccountRequest {
    return new AdminUpdateAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminUpdateAccountRequest {
    return new AdminUpdateAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdminUpdateAccountRequest | PlainMessage<AdminUpdateAccountRequest> | undefined, b: AdminUpdateAccountRequest | PlainMessage<AdminUpdateAccountRequest> | undefined): boolean {
    return proto3.util.equals(AdminUpdateAccountRequest, a, b);
  }
}

/**
 * @generated from message account.AdminGetAccountRequest
 */
export class AdminGetAccountRequest extends Message<AdminGetAccountRequest> {
  /**
   * The name of the account to get
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<AdminGetAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdminGetAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminGetAccountRequest {
    return new AdminGetAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminGetAccountRequest {
    return new AdminGetAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminGetAccountRequest {
    return new AdminGetAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdminGetAccountRequest | PlainMessage<AdminGetAccountRequest> | undefined, b: AdminGetAccountRequest | PlainMessage<AdminGetAccountRequest> | undefined): boolean {
    return proto3.util.equals(AdminGetAccountRequest, a, b);
  }
}

/**
 * @generated from message account.AdminDeleteAccountRequest
 */
export class AdminDeleteAccountRequest extends Message<AdminDeleteAccountRequest> {
  /**
   * The name of the account to delete
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<AdminDeleteAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdminDeleteAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminDeleteAccountRequest {
    return new AdminDeleteAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminDeleteAccountRequest {
    return new AdminDeleteAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminDeleteAccountRequest {
    return new AdminDeleteAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdminDeleteAccountRequest | PlainMessage<AdminDeleteAccountRequest> | undefined, b: AdminDeleteAccountRequest | PlainMessage<AdminDeleteAccountRequest> | undefined): boolean {
    return proto3.util.equals(AdminDeleteAccountRequest, a, b);
  }
}

/**
 * @generated from message account.AdminDeleteAccountResponse
 */
export class AdminDeleteAccountResponse extends Message<AdminDeleteAccountResponse> {
  constructor(data?: PartialMessage<AdminDeleteAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdminDeleteAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminDeleteAccountResponse {
    return new AdminDeleteAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminDeleteAccountResponse {
    return new AdminDeleteAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminDeleteAccountResponse {
    return new AdminDeleteAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AdminDeleteAccountResponse | PlainMessage<AdminDeleteAccountResponse> | undefined, b: AdminDeleteAccountResponse | PlainMessage<AdminDeleteAccountResponse> | undefined): boolean {
    return proto3.util.equals(AdminDeleteAccountResponse, a, b);
  }
}

/**
 * @generated from message account.AdminListSourcesRequest
 */
export class AdminListSourcesRequest extends Message<AdminListSourcesRequest> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: account.ListSourcesRequest request = 2;
   */
  request?: ListSourcesRequest;

  constructor(data?: PartialMessage<AdminListSourcesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdminListSourcesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "request", kind: "message", T: ListSourcesRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminListSourcesRequest {
    return new AdminListSourcesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminListSourcesRequest {
    return new AdminListSourcesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminListSourcesRequest {
    return new AdminListSourcesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdminListSourcesRequest | PlainMessage<AdminListSourcesRequest> | undefined, b: AdminListSourcesRequest | PlainMessage<AdminListSourcesRequest> | undefined): boolean {
    return proto3.util.equals(AdminListSourcesRequest, a, b);
  }
}

/**
 * @generated from message account.AdminCreateSourceRequest
 */
export class AdminCreateSourceRequest extends Message<AdminCreateSourceRequest> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: account.CreateSourceRequest request = 2;
   */
  request?: CreateSourceRequest;

  constructor(data?: PartialMessage<AdminCreateSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdminCreateSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "request", kind: "message", T: CreateSourceRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminCreateSourceRequest {
    return new AdminCreateSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminCreateSourceRequest {
    return new AdminCreateSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminCreateSourceRequest {
    return new AdminCreateSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdminCreateSourceRequest | PlainMessage<AdminCreateSourceRequest> | undefined, b: AdminCreateSourceRequest | PlainMessage<AdminCreateSourceRequest> | undefined): boolean {
    return proto3.util.equals(AdminCreateSourceRequest, a, b);
  }
}

/**
 * @generated from message account.AdminGetSourceRequest
 */
export class AdminGetSourceRequest extends Message<AdminGetSourceRequest> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: account.GetSourceRequest request = 2;
   */
  request?: GetSourceRequest;

  constructor(data?: PartialMessage<AdminGetSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdminGetSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "request", kind: "message", T: GetSourceRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminGetSourceRequest {
    return new AdminGetSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminGetSourceRequest {
    return new AdminGetSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminGetSourceRequest {
    return new AdminGetSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdminGetSourceRequest | PlainMessage<AdminGetSourceRequest> | undefined, b: AdminGetSourceRequest | PlainMessage<AdminGetSourceRequest> | undefined): boolean {
    return proto3.util.equals(AdminGetSourceRequest, a, b);
  }
}

/**
 * @generated from message account.AdminUpdateSourceRequest
 */
export class AdminUpdateSourceRequest extends Message<AdminUpdateSourceRequest> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: account.UpdateSourceRequest request = 2;
   */
  request?: UpdateSourceRequest;

  constructor(data?: PartialMessage<AdminUpdateSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdminUpdateSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "request", kind: "message", T: UpdateSourceRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminUpdateSourceRequest {
    return new AdminUpdateSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminUpdateSourceRequest {
    return new AdminUpdateSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminUpdateSourceRequest {
    return new AdminUpdateSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdminUpdateSourceRequest | PlainMessage<AdminUpdateSourceRequest> | undefined, b: AdminUpdateSourceRequest | PlainMessage<AdminUpdateSourceRequest> | undefined): boolean {
    return proto3.util.equals(AdminUpdateSourceRequest, a, b);
  }
}

/**
 * @generated from message account.AdminDeleteSourceRequest
 */
export class AdminDeleteSourceRequest extends Message<AdminDeleteSourceRequest> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: account.DeleteSourceRequest request = 2;
   */
  request?: DeleteSourceRequest;

  constructor(data?: PartialMessage<AdminDeleteSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdminDeleteSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "request", kind: "message", T: DeleteSourceRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminDeleteSourceRequest {
    return new AdminDeleteSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminDeleteSourceRequest {
    return new AdminDeleteSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminDeleteSourceRequest {
    return new AdminDeleteSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdminDeleteSourceRequest | PlainMessage<AdminDeleteSourceRequest> | undefined, b: AdminDeleteSourceRequest | PlainMessage<AdminDeleteSourceRequest> | undefined): boolean {
    return proto3.util.equals(AdminDeleteSourceRequest, a, b);
  }
}

/**
 * @generated from message account.AdminKeepaliveSourcesRequest
 */
export class AdminKeepaliveSourcesRequest extends Message<AdminKeepaliveSourcesRequest> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: account.KeepaliveSourcesRequest request = 2;
   */
  request?: KeepaliveSourcesRequest;

  constructor(data?: PartialMessage<AdminKeepaliveSourcesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdminKeepaliveSourcesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "request", kind: "message", T: KeepaliveSourcesRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminKeepaliveSourcesRequest {
    return new AdminKeepaliveSourcesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminKeepaliveSourcesRequest {
    return new AdminKeepaliveSourcesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminKeepaliveSourcesRequest {
    return new AdminKeepaliveSourcesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdminKeepaliveSourcesRequest | PlainMessage<AdminKeepaliveSourcesRequest> | undefined, b: AdminKeepaliveSourcesRequest | PlainMessage<AdminKeepaliveSourcesRequest> | undefined): boolean {
    return proto3.util.equals(AdminKeepaliveSourcesRequest, a, b);
  }
}

/**
 * @generated from message account.AdminCreateTokenRequest
 */
export class AdminCreateTokenRequest extends Message<AdminCreateTokenRequest> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: account.CreateTokenRequest request = 2;
   */
  request?: CreateTokenRequest;

  constructor(data?: PartialMessage<AdminCreateTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdminCreateTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "request", kind: "message", T: CreateTokenRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminCreateTokenRequest {
    return new AdminCreateTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminCreateTokenRequest {
    return new AdminCreateTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminCreateTokenRequest {
    return new AdminCreateTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdminCreateTokenRequest | PlainMessage<AdminCreateTokenRequest> | undefined, b: AdminCreateTokenRequest | PlainMessage<AdminCreateTokenRequest> | undefined): boolean {
    return proto3.util.equals(AdminCreateTokenRequest, a, b);
  }
}

/**
 * @generated from message account.Source
 */
export class Source extends Message<Source> {
  /**
   * @generated from field: account.SourceMetadata metadata = 1;
   */
  metadata?: SourceMetadata;

  /**
   * @generated from field: account.SourceProperties properties = 2;
   */
  properties?: SourceProperties;

  constructor(data?: PartialMessage<Source>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.Source";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: SourceMetadata },
    { no: 2, name: "properties", kind: "message", T: SourceProperties },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source {
    return new Source().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJsonString(jsonString, options);
  }

  static equals(a: Source | PlainMessage<Source> | undefined, b: Source | PlainMessage<Source> | undefined): boolean {
    return proto3.util.equals(Source, a, b);
  }
}

/**
 * @generated from message account.SourceMetadata
 */
export class SourceMetadata extends Message<SourceMetadata> {
  /**
   * TODO: Change to ID along with everything else
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  /**
   * The name of the NATS JWT that has been generated for this source
   *
   * @generated from field: string TokenName = 2;
   */
  TokenName = "";

  /**
   * When the NATS JWT expires (unix time)
   *
   * @generated from field: google.protobuf.Timestamp TokenExpiry = 4;
   */
  TokenExpiry?: Timestamp;

  /**
   * The public NKey associated with the NATS JWT
   *
   * @generated from field: string PublicNkey = 5;
   */
  PublicNkey = "";

  /**
   * Status of the source
   *
   * @generated from field: account.SourceStatus Status = 9;
   */
  Status = SourceStatus.STATUS_UNSPECIFIED;

  /**
   * The error message if the source is unhealthy
   *
   * @generated from field: string Error = 10;
   */
  Error = "";

  constructor(data?: PartialMessage<SourceMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.SourceMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "TokenName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "TokenExpiry", kind: "message", T: Timestamp },
    { no: 5, name: "PublicNkey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "Status", kind: "enum", T: proto3.getEnumType(SourceStatus) },
    { no: 10, name: "Error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceMetadata {
    return new SourceMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceMetadata {
    return new SourceMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceMetadata {
    return new SourceMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SourceMetadata | PlainMessage<SourceMetadata> | undefined, b: SourceMetadata | PlainMessage<SourceMetadata> | undefined): boolean {
    return proto3.util.equals(SourceMetadata, a, b);
  }
}

/**
 * A source that is capable of discovering items
 *
 * @generated from message account.SourceProperties
 */
export class SourceProperties extends Message<SourceProperties> {
  /**
   * The descriptive name of the source
   *
   * @generated from field: string DescriptiveName = 1;
   */
  DescriptiveName = "";

  /**
   * What source to configure. Currently either "stdlib" or "aws"
   *
   * @generated from field: string Type = 2;
   */
  Type = "";

  /**
   * Config for this source. See the source documentation for what
   * source-specific config is available/required. This will be supplied
   * directly to viper via a config file at `/etc/srcman/config/source.yaml`
   *
   * @generated from field: google.protobuf.Struct Config = 3;
   */
  Config?: Struct;

  /**
   * Additional config options that should be passed to the source. The keys
   * of this object should be file names, and the values should be their
   * content. These files will be made available to the source at runtime.
   * Check the source's documentation for what to configure here if required
   *
   * @generated from field: google.protobuf.Struct AdditionalConfig = 4;
   */
  AdditionalConfig?: Struct;

  constructor(data?: PartialMessage<SourceProperties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.SourceProperties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "DescriptiveName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Config", kind: "message", T: Struct },
    { no: 4, name: "AdditionalConfig", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceProperties {
    return new SourceProperties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceProperties {
    return new SourceProperties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceProperties {
    return new SourceProperties().fromJsonString(jsonString, options);
  }

  static equals(a: SourceProperties | PlainMessage<SourceProperties> | undefined, b: SourceProperties | PlainMessage<SourceProperties> | undefined): boolean {
    return proto3.util.equals(SourceProperties, a, b);
  }
}

/**
 * @generated from message account.Account
 */
export class Account extends Message<Account> {
  /**
   * @generated from field: account.AccountMetadata metadata = 1;
   */
  metadata?: AccountMetadata;

  /**
   * @generated from field: account.AccountProperties properties = 2;
   */
  properties?: AccountProperties;

  constructor(data?: PartialMessage<Account>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.Account";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: AccountMetadata },
    { no: 2, name: "properties", kind: "message", T: AccountProperties },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Account {
    return new Account().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Account {
    return new Account().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Account {
    return new Account().fromJsonString(jsonString, options);
  }

  static equals(a: Account | PlainMessage<Account> | undefined, b: Account | PlainMessage<Account> | undefined): boolean {
    return proto3.util.equals(Account, a, b);
  }
}

/**
 * @generated from message account.AccountMetadata
 */
export class AccountMetadata extends Message<AccountMetadata> {
  /**
   * The public Nkey which signs all NATS "user" tokens
   *
   * @generated from field: string PublicNkey = 2;
   */
  PublicNkey = "";

  constructor(data?: PartialMessage<AccountMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AccountMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "PublicNkey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountMetadata {
    return new AccountMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountMetadata {
    return new AccountMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountMetadata {
    return new AccountMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AccountMetadata | PlainMessage<AccountMetadata> | undefined, b: AccountMetadata | PlainMessage<AccountMetadata> | undefined): boolean {
    return proto3.util.equals(AccountMetadata, a, b);
  }
}

/**
 * @generated from message account.AccountProperties
 */
export class AccountProperties extends Message<AccountProperties> {
  /**
   * The name of the account
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * The Customer ID within Stripe
   *
   * @generated from field: string StripeCustomerID = 2;
   */
  StripeCustomerID = "";

  constructor(data?: PartialMessage<AccountProperties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AccountProperties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "StripeCustomerID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountProperties {
    return new AccountProperties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountProperties {
    return new AccountProperties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountProperties {
    return new AccountProperties().fromJsonString(jsonString, options);
  }

  static equals(a: AccountProperties | PlainMessage<AccountProperties> | undefined, b: AccountProperties | PlainMessage<AccountProperties> | undefined): boolean {
    return proto3.util.equals(AccountProperties, a, b);
  }
}

/**
 * @generated from message account.GetAccountRequest
 */
export class GetAccountRequest extends Message<GetAccountRequest> {
  constructor(data?: PartialMessage<GetAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.GetAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountRequest {
    return new GetAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountRequest {
    return new GetAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountRequest {
    return new GetAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountRequest | PlainMessage<GetAccountRequest> | undefined, b: GetAccountRequest | PlainMessage<GetAccountRequest> | undefined): boolean {
    return proto3.util.equals(GetAccountRequest, a, b);
  }
}

/**
 * @generated from message account.GetAccountResponse
 */
export class GetAccountResponse extends Message<GetAccountResponse> {
  /**
   * @generated from field: account.Account account = 1;
   */
  account?: Account;

  constructor(data?: PartialMessage<GetAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.GetAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "message", T: Account },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountResponse {
    return new GetAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountResponse {
    return new GetAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountResponse {
    return new GetAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountResponse | PlainMessage<GetAccountResponse> | undefined, b: GetAccountResponse | PlainMessage<GetAccountResponse> | undefined): boolean {
    return proto3.util.equals(GetAccountResponse, a, b);
  }
}

/**
 * @generated from message account.DeleteAccountRequest
 */
export class DeleteAccountRequest extends Message<DeleteAccountRequest> {
  /**
   * Set to true to confirm that the user is sure they want to delete their
   * account. This is to prevent accidental deletions
   *
   * @generated from field: bool iAmSure = 1;
   */
  iAmSure = false;

  constructor(data?: PartialMessage<DeleteAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.DeleteAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "iAmSure", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAccountRequest {
    return new DeleteAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAccountRequest {
    return new DeleteAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAccountRequest {
    return new DeleteAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAccountRequest | PlainMessage<DeleteAccountRequest> | undefined, b: DeleteAccountRequest | PlainMessage<DeleteAccountRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAccountRequest, a, b);
  }
}

/**
 * @generated from message account.DeleteAccountResponse
 */
export class DeleteAccountResponse extends Message<DeleteAccountResponse> {
  constructor(data?: PartialMessage<DeleteAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.DeleteAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAccountResponse {
    return new DeleteAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAccountResponse {
    return new DeleteAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAccountResponse {
    return new DeleteAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAccountResponse | PlainMessage<DeleteAccountResponse> | undefined, b: DeleteAccountResponse | PlainMessage<DeleteAccountResponse> | undefined): boolean {
    return proto3.util.equals(DeleteAccountResponse, a, b);
  }
}

/**
 * @generated from message account.ListSourcesRequest
 */
export class ListSourcesRequest extends Message<ListSourcesRequest> {
  constructor(data?: PartialMessage<ListSourcesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.ListSourcesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSourcesRequest {
    return new ListSourcesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSourcesRequest {
    return new ListSourcesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSourcesRequest {
    return new ListSourcesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSourcesRequest | PlainMessage<ListSourcesRequest> | undefined, b: ListSourcesRequest | PlainMessage<ListSourcesRequest> | undefined): boolean {
    return proto3.util.equals(ListSourcesRequest, a, b);
  }
}

/**
 * @generated from message account.ListSourcesResponse
 */
export class ListSourcesResponse extends Message<ListSourcesResponse> {
  /**
   * @generated from field: repeated account.Source Sources = 1;
   */
  Sources: Source[] = [];

  constructor(data?: PartialMessage<ListSourcesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.ListSourcesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Sources", kind: "message", T: Source, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSourcesResponse {
    return new ListSourcesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSourcesResponse {
    return new ListSourcesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSourcesResponse {
    return new ListSourcesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSourcesResponse | PlainMessage<ListSourcesResponse> | undefined, b: ListSourcesResponse | PlainMessage<ListSourcesResponse> | undefined): boolean {
    return proto3.util.equals(ListSourcesResponse, a, b);
  }
}

/**
 * @generated from message account.CreateSourceRequest
 */
export class CreateSourceRequest extends Message<CreateSourceRequest> {
  /**
   * @generated from field: account.SourceProperties properties = 1;
   */
  properties?: SourceProperties;

  constructor(data?: PartialMessage<CreateSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.CreateSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "properties", kind: "message", T: SourceProperties },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSourceRequest {
    return new CreateSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSourceRequest {
    return new CreateSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSourceRequest {
    return new CreateSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSourceRequest | PlainMessage<CreateSourceRequest> | undefined, b: CreateSourceRequest | PlainMessage<CreateSourceRequest> | undefined): boolean {
    return proto3.util.equals(CreateSourceRequest, a, b);
  }
}

/**
 * @generated from message account.CreateSourceResponse
 */
export class CreateSourceResponse extends Message<CreateSourceResponse> {
  /**
   * @generated from field: account.Source source = 1;
   */
  source?: Source;

  constructor(data?: PartialMessage<CreateSourceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.CreateSourceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: Source },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSourceResponse {
    return new CreateSourceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSourceResponse {
    return new CreateSourceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSourceResponse {
    return new CreateSourceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSourceResponse | PlainMessage<CreateSourceResponse> | undefined, b: CreateSourceResponse | PlainMessage<CreateSourceResponse> | undefined): boolean {
    return proto3.util.equals(CreateSourceResponse, a, b);
  }
}

/**
 * @generated from message account.GetSourceRequest
 */
export class GetSourceRequest extends Message<GetSourceRequest> {
  /**
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  constructor(data?: PartialMessage<GetSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.GetSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSourceRequest {
    return new GetSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSourceRequest {
    return new GetSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSourceRequest {
    return new GetSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSourceRequest | PlainMessage<GetSourceRequest> | undefined, b: GetSourceRequest | PlainMessage<GetSourceRequest> | undefined): boolean {
    return proto3.util.equals(GetSourceRequest, a, b);
  }
}

/**
 * @generated from message account.GetSourceResponse
 */
export class GetSourceResponse extends Message<GetSourceResponse> {
  /**
   * @generated from field: account.Source source = 1;
   */
  source?: Source;

  constructor(data?: PartialMessage<GetSourceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.GetSourceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: Source },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSourceResponse {
    return new GetSourceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSourceResponse {
    return new GetSourceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSourceResponse {
    return new GetSourceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSourceResponse | PlainMessage<GetSourceResponse> | undefined, b: GetSourceResponse | PlainMessage<GetSourceResponse> | undefined): boolean {
    return proto3.util.equals(GetSourceResponse, a, b);
  }
}

/**
 * @generated from message account.UpdateSourceRequest
 */
export class UpdateSourceRequest extends Message<UpdateSourceRequest> {
  /**
   * ID of the source to update
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  /**
   * Properties to update
   *
   * @generated from field: account.SourceProperties properties = 2;
   */
  properties?: SourceProperties;

  constructor(data?: PartialMessage<UpdateSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.UpdateSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "properties", kind: "message", T: SourceProperties },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateSourceRequest {
    return new UpdateSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateSourceRequest {
    return new UpdateSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateSourceRequest {
    return new UpdateSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateSourceRequest | PlainMessage<UpdateSourceRequest> | undefined, b: UpdateSourceRequest | PlainMessage<UpdateSourceRequest> | undefined): boolean {
    return proto3.util.equals(UpdateSourceRequest, a, b);
  }
}

/**
 * @generated from message account.UpdateSourceResponse
 */
export class UpdateSourceResponse extends Message<UpdateSourceResponse> {
  /**
   * @generated from field: account.Source source = 1;
   */
  source?: Source;

  constructor(data?: PartialMessage<UpdateSourceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.UpdateSourceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: Source },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateSourceResponse {
    return new UpdateSourceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateSourceResponse {
    return new UpdateSourceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateSourceResponse {
    return new UpdateSourceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateSourceResponse | PlainMessage<UpdateSourceResponse> | undefined, b: UpdateSourceResponse | PlainMessage<UpdateSourceResponse> | undefined): boolean {
    return proto3.util.equals(UpdateSourceResponse, a, b);
  }
}

/**
 * @generated from message account.DeleteSourceRequest
 */
export class DeleteSourceRequest extends Message<DeleteSourceRequest> {
  /**
   * ID if the source to delete
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  constructor(data?: PartialMessage<DeleteSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.DeleteSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSourceRequest {
    return new DeleteSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSourceRequest {
    return new DeleteSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSourceRequest {
    return new DeleteSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSourceRequest | PlainMessage<DeleteSourceRequest> | undefined, b: DeleteSourceRequest | PlainMessage<DeleteSourceRequest> | undefined): boolean {
    return proto3.util.equals(DeleteSourceRequest, a, b);
  }
}

/**
 * @generated from message account.DeleteSourceResponse
 */
export class DeleteSourceResponse extends Message<DeleteSourceResponse> {
  constructor(data?: PartialMessage<DeleteSourceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.DeleteSourceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSourceResponse {
    return new DeleteSourceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSourceResponse {
    return new DeleteSourceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSourceResponse {
    return new DeleteSourceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSourceResponse | PlainMessage<DeleteSourceResponse> | undefined, b: DeleteSourceResponse | PlainMessage<DeleteSourceResponse> | undefined): boolean {
    return proto3.util.equals(DeleteSourceResponse, a, b);
  }
}

/**
 * @generated from message account.SourceKeepaliveResult
 */
export class SourceKeepaliveResult extends Message<SourceKeepaliveResult> {
  /**
   * The UUID of the source that was kept alive
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  /**
   * The status of the source
   *
   * @generated from field: account.SourceStatus Status = 2;
   */
  Status = SourceStatus.STATUS_UNSPECIFIED;

  /**
   * The error message if the source is unhealthy
   *
   * @generated from field: string Error = 3;
   */
  Error = "";

  constructor(data?: PartialMessage<SourceKeepaliveResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.SourceKeepaliveResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "Status", kind: "enum", T: proto3.getEnumType(SourceStatus) },
    { no: 3, name: "Error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceKeepaliveResult {
    return new SourceKeepaliveResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceKeepaliveResult {
    return new SourceKeepaliveResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceKeepaliveResult {
    return new SourceKeepaliveResult().fromJsonString(jsonString, options);
  }

  static equals(a: SourceKeepaliveResult | PlainMessage<SourceKeepaliveResult> | undefined, b: SourceKeepaliveResult | PlainMessage<SourceKeepaliveResult> | undefined): boolean {
    return proto3.util.equals(SourceKeepaliveResult, a, b);
  }
}

/**
 * @generated from message account.ListAllSourcesStatusRequest
 */
export class ListAllSourcesStatusRequest extends Message<ListAllSourcesStatusRequest> {
  constructor(data?: PartialMessage<ListAllSourcesStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.ListAllSourcesStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAllSourcesStatusRequest {
    return new ListAllSourcesStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAllSourcesStatusRequest {
    return new ListAllSourcesStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAllSourcesStatusRequest {
    return new ListAllSourcesStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAllSourcesStatusRequest | PlainMessage<ListAllSourcesStatusRequest> | undefined, b: ListAllSourcesStatusRequest | PlainMessage<ListAllSourcesStatusRequest> | undefined): boolean {
    return proto3.util.equals(ListAllSourcesStatusRequest, a, b);
  }
}

/**
 * @generated from message account.SourceHealth
 */
export class SourceHealth extends Message<SourceHealth> {
  /**
   * The UUID of the source
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  /**
   * The version of the source
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * The name of the source
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * The error message if the source is unhealthy
   *
   * @generated from field: optional string error = 4;
   */
  error?: string;

  /**
   * The status of the source, this is calculated based on the last heartbeat received and if there is an error
   *
   * @generated from field: account.SourceStatus status = 5;
   */
  status = SourceStatus.STATUS_UNSPECIFIED;

  /**
   * Created at time
   *
   * @generated from field: google.protobuf.Timestamp createdAt = 6;
   */
  createdAt?: Timestamp;

  /**
   * The last time we received a heartbeat from the source
   *
   * @generated from field: google.protobuf.Timestamp lastHeartbeat = 7;
   */
  lastHeartbeat?: Timestamp;

  /**
   * The next time we expect to receive a heartbeat from the source
   *
   * @generated from field: google.protobuf.Timestamp nextHeartbeat = 8;
   */
  nextHeartbeat?: Timestamp;

  /**
   * The type of the source, AWS or Stdlib or Kubernetes
   *
   * @generated from field: string type = 9;
   */
  type = "";

  /**
   * Whether the source is managed, or local
   *
   * @generated from field: account.SourceManaged managed = 10;
   */
  managed = SourceManaged.LOCAL;

  /**
   * The types of sources that this source can discover
   *
   * @generated from field: repeated string availableTypes = 11;
   */
  availableTypes: string[] = [];

  /**
   * The scopes that this source can discover
   *
   * @generated from field: repeated string availableScopes = 12;
   */
  availableScopes: string[] = [];

  /**
   * AdapterMetadata is a map of metadata that the source can send to the API
   *
   * @generated from field: repeated account.AdapterMetadata adapterMetadata = 13;
   */
  adapterMetadata: AdapterMetadata[] = [];

  constructor(data?: PartialMessage<SourceHealth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.SourceHealth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "status", kind: "enum", T: proto3.getEnumType(SourceStatus) },
    { no: 6, name: "createdAt", kind: "message", T: Timestamp },
    { no: 7, name: "lastHeartbeat", kind: "message", T: Timestamp },
    { no: 8, name: "nextHeartbeat", kind: "message", T: Timestamp },
    { no: 9, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "managed", kind: "enum", T: proto3.getEnumType(SourceManaged) },
    { no: 11, name: "availableTypes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 12, name: "availableScopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 13, name: "adapterMetadata", kind: "message", T: AdapterMetadata, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceHealth {
    return new SourceHealth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceHealth {
    return new SourceHealth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceHealth {
    return new SourceHealth().fromJsonString(jsonString, options);
  }

  static equals(a: SourceHealth | PlainMessage<SourceHealth> | undefined, b: SourceHealth | PlainMessage<SourceHealth> | undefined): boolean {
    return proto3.util.equals(SourceHealth, a, b);
  }
}

/**
 * @generated from message account.ListAllSourcesStatusResponse
 */
export class ListAllSourcesStatusResponse extends Message<ListAllSourcesStatusResponse> {
  /**
   * @generated from field: repeated account.SourceHealth sources = 1;
   */
  sources: SourceHealth[] = [];

  constructor(data?: PartialMessage<ListAllSourcesStatusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.ListAllSourcesStatusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sources", kind: "message", T: SourceHealth, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAllSourcesStatusResponse {
    return new ListAllSourcesStatusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAllSourcesStatusResponse {
    return new ListAllSourcesStatusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAllSourcesStatusResponse {
    return new ListAllSourcesStatusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAllSourcesStatusResponse | PlainMessage<ListAllSourcesStatusResponse> | undefined, b: ListAllSourcesStatusResponse | PlainMessage<ListAllSourcesStatusResponse> | undefined): boolean {
    return proto3.util.equals(ListAllSourcesStatusResponse, a, b);
  }
}

/**
 * The source sends a heartbeat to the API to let it know that it is still alive, note it does not give a status.
 *
 * @generated from message account.SubmitSourceHeartbeatRequest
 */
export class SubmitSourceHeartbeatRequest extends Message<SubmitSourceHeartbeatRequest> {
  /**
   * The UUID of the source that is sending the heartbeat
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  /**
   * The version of the source
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * The name of the source
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * The error message if the source is unhealthy
   *
   * @generated from field: optional string error = 4;
   */
  error?: string;

  /**
   * The maximum time between heartbeats that the source can send to the api-server. Otherwise, the source will be marked as unhealthy. eg 30s
   *
   * @generated from field: google.protobuf.Duration nextHeartbeatMax = 5;
   */
  nextHeartbeatMax?: Duration;

  /**
   * The type of the source, AWS or Stdlib or Kubernetes
   *
   * @generated from field: string type = 6;
   */
  type = "";

  /**
   * Whether the source is managed, or local
   *
   * @generated from field: account.SourceManaged managed = 7;
   */
  managed = SourceManaged.LOCAL;

  /**
   * The scopes that this source can discover
   *
   * @generated from field: repeated string availableScopes = 9;
   */
  availableScopes: string[] = [];

  /**
   * AdapterMetadata is a map of metadata that the source can send to the API
   *
   * @generated from field: repeated account.AdapterMetadata adapterMetadata = 10;
   */
  adapterMetadata: AdapterMetadata[] = [];

  constructor(data?: PartialMessage<SubmitSourceHeartbeatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.SubmitSourceHeartbeatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "nextHeartbeatMax", kind: "message", T: Duration },
    { no: 6, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "managed", kind: "enum", T: proto3.getEnumType(SourceManaged) },
    { no: 9, name: "availableScopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "adapterMetadata", kind: "message", T: AdapterMetadata, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitSourceHeartbeatRequest {
    return new SubmitSourceHeartbeatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitSourceHeartbeatRequest {
    return new SubmitSourceHeartbeatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitSourceHeartbeatRequest {
    return new SubmitSourceHeartbeatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitSourceHeartbeatRequest | PlainMessage<SubmitSourceHeartbeatRequest> | undefined, b: SubmitSourceHeartbeatRequest | PlainMessage<SubmitSourceHeartbeatRequest> | undefined): boolean {
    return proto3.util.equals(SubmitSourceHeartbeatRequest, a, b);
  }
}

/**
 * @generated from message account.AdapterMetadata
 */
export class AdapterMetadata extends Message<AdapterMetadata> {
  /**
   * The type of item that this adapter returns e.g. eks-cluster
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * The category that these items fall under
   *
   * @generated from field: account.AdapterCategory category = 2;
   */
  category = AdapterCategory.OTHER;

  /**
   * The list of other types that this can be linked to, eg eks-cluster ->
   * eks-node-group
   *
   * @generated from field: repeated string potentialLinks = 3;
   */
  potentialLinks: string[] = [];

  /**
   * A descriptive name of the types of items that are returned by this
   * adapter e.g. "EKS Cluster"
   *
   * @generated from field: string descriptiveName = 4;
   */
  descriptiveName = "";

  /**
   * The supported query methods for this adapter
   *
   * @generated from field: account.AdapterSupportedQueryMethods supportedQueryMethods = 5;
   */
  supportedQueryMethods?: AdapterSupportedQueryMethods;

  /**
   * The terraform mappings for this adapter, this is optional
   *
   * @generated from field: repeated account.TerraformMapping terraformMappings = 6;
   */
  terraformMappings: TerraformMapping[] = [];

  constructor(data?: PartialMessage<AdapterMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdapterMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "category", kind: "enum", T: proto3.getEnumType(AdapterCategory) },
    { no: 3, name: "potentialLinks", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "descriptiveName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "supportedQueryMethods", kind: "message", T: AdapterSupportedQueryMethods },
    { no: 6, name: "terraformMappings", kind: "message", T: TerraformMapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdapterMetadata {
    return new AdapterMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdapterMetadata {
    return new AdapterMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdapterMetadata {
    return new AdapterMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AdapterMetadata | PlainMessage<AdapterMetadata> | undefined, b: AdapterMetadata | PlainMessage<AdapterMetadata> | undefined): boolean {
    return proto3.util.equals(AdapterMetadata, a, b);
  }
}

/**
 * The methods that this adapter supports, and the description of how to use
 * them
 *
 * @generated from message account.AdapterSupportedQueryMethods
 */
export class AdapterSupportedQueryMethods extends Message<AdapterSupportedQueryMethods> {
  /**
   * Whether or not the GET method is supported
   *
   * @generated from field: bool get = 1;
   */
  get = false;

  /**
   * Description of the query that should be passed to the GET method
   *
   * @generated from field: string getDescription = 2;
   */
  getDescription = "";

  /**
   * Whether or not the LIST method is supported
   *
   * @generated from field: bool list = 3;
   */
  list = false;

  /**
   * Description of how the LIST method works
   *
   * @generated from field: string listDescription = 4;
   */
  listDescription = "";

  /**
   * Whether or not the SEARCH method is supported
   *
   * @generated from field: bool search = 5;
   */
  search = false;

  /**
   * Description of the query that should be passed to the SEARCH method
   *
   * @generated from field: string searchDescription = 6;
   */
  searchDescription = "";

  constructor(data?: PartialMessage<AdapterSupportedQueryMethods>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AdapterSupportedQueryMethods";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "get", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "getDescription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "list", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "listDescription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "search", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "searchDescription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdapterSupportedQueryMethods {
    return new AdapterSupportedQueryMethods().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdapterSupportedQueryMethods {
    return new AdapterSupportedQueryMethods().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdapterSupportedQueryMethods {
    return new AdapterSupportedQueryMethods().fromJsonString(jsonString, options);
  }

  static equals(a: AdapterSupportedQueryMethods | PlainMessage<AdapterSupportedQueryMethods> | undefined, b: AdapterSupportedQueryMethods | PlainMessage<AdapterSupportedQueryMethods> | undefined): boolean {
    return proto3.util.equals(AdapterSupportedQueryMethods, a, b);
  }
}

/**
 * When Overmind ingests Terraform changes, it needs to be able to map from a
 * given Terraform resource, to that same resource in Overmind. This is achieved
 * by using the TerraformMapping object. It translates the details of a Terraform
 * resource into a query that Overmind can run.
 *
 * NOTE: The queries that are generated by this mapping use the wildcard scope
 * `*` and therefore could return multiple items. Overmind will compare the
 * attributes of these items to determine the most likely candidate for a mch
 * and select that.
 *
 * @generated from message account.TerraformMapping
 */
export class TerraformMapping extends Message<TerraformMapping> {
  /**
   * The method that the query should use
   *
   * @generated from field: QueryMethod terraformMethod = 1;
   */
  terraformMethod = QueryMethod.GET;

  /**
   * How to map data from the terraform resource to the "query" field in the
   * resulting mapping query. This uses HCL syntax  e.g.
   * resource_type.attribute_name
   *
   * Usually this will be the attribute that uniquely identifies the resource
   * such as `aws_instance.id` or `aws_iam_role.arn`. You can also index into
   * arrays e.g. `kubernetes_replication_controller.metadata[0].name`
   *
   * @generated from field: string terraformQueryMap = 2;
   */
  terraformQueryMap = "";

  constructor(data?: PartialMessage<TerraformMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.TerraformMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "terraformMethod", kind: "enum", T: proto3.getEnumType(QueryMethod) },
    { no: 2, name: "terraformQueryMap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TerraformMapping {
    return new TerraformMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TerraformMapping {
    return new TerraformMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TerraformMapping {
    return new TerraformMapping().fromJsonString(jsonString, options);
  }

  static equals(a: TerraformMapping | PlainMessage<TerraformMapping> | undefined, b: TerraformMapping | PlainMessage<TerraformMapping> | undefined): boolean {
    return proto3.util.equals(TerraformMapping, a, b);
  }
}

/**
 * @generated from message account.SubmitSourceHeartbeatResponse
 */
export class SubmitSourceHeartbeatResponse extends Message<SubmitSourceHeartbeatResponse> {
  constructor(data?: PartialMessage<SubmitSourceHeartbeatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.SubmitSourceHeartbeatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitSourceHeartbeatResponse {
    return new SubmitSourceHeartbeatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitSourceHeartbeatResponse {
    return new SubmitSourceHeartbeatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitSourceHeartbeatResponse {
    return new SubmitSourceHeartbeatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitSourceHeartbeatResponse | PlainMessage<SubmitSourceHeartbeatResponse> | undefined, b: SubmitSourceHeartbeatResponse | PlainMessage<SubmitSourceHeartbeatResponse> | undefined): boolean {
    return proto3.util.equals(SubmitSourceHeartbeatResponse, a, b);
  }
}

/**
 * @generated from message account.KeepaliveSourcesRequest
 */
export class KeepaliveSourcesRequest extends Message<KeepaliveSourcesRequest> {
  /**
   * Set to true to have the API call wait until the source is up and healthy
   *
   * @generated from field: bool waitForHealthy = 1;
   */
  waitForHealthy = false;

  constructor(data?: PartialMessage<KeepaliveSourcesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.KeepaliveSourcesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "waitForHealthy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeepaliveSourcesRequest {
    return new KeepaliveSourcesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeepaliveSourcesRequest {
    return new KeepaliveSourcesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeepaliveSourcesRequest {
    return new KeepaliveSourcesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: KeepaliveSourcesRequest | PlainMessage<KeepaliveSourcesRequest> | undefined, b: KeepaliveSourcesRequest | PlainMessage<KeepaliveSourcesRequest> | undefined): boolean {
    return proto3.util.equals(KeepaliveSourcesRequest, a, b);
  }
}

/**
 * @generated from message account.KeepaliveSourcesResponse
 */
export class KeepaliveSourcesResponse extends Message<KeepaliveSourcesResponse> {
  /**
   * If the user requested to wait for the sources to be healthy, this will
   * contain information about the sources that came up. If the user did not
   * request to wait, this will be empty
   *
   * @generated from field: repeated account.SourceKeepaliveResult sources = 1;
   */
  sources: SourceKeepaliveResult[] = [];

  constructor(data?: PartialMessage<KeepaliveSourcesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.KeepaliveSourcesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sources", kind: "message", T: SourceKeepaliveResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeepaliveSourcesResponse {
    return new KeepaliveSourcesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeepaliveSourcesResponse {
    return new KeepaliveSourcesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeepaliveSourcesResponse {
    return new KeepaliveSourcesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: KeepaliveSourcesResponse | PlainMessage<KeepaliveSourcesResponse> | undefined, b: KeepaliveSourcesResponse | PlainMessage<KeepaliveSourcesResponse> | undefined): boolean {
    return proto3.util.equals(KeepaliveSourcesResponse, a, b);
  }
}

/**
 * @generated from message account.CreateTokenRequest
 */
export class CreateTokenRequest extends Message<CreateTokenRequest> {
  /**
   * The Public NKey of the user that is requesting a token
   *
   * @generated from field: string userPublicNkey = 1;
   */
  userPublicNkey = "";

  /**
   * Friendly user name
   *
   * @generated from field: string userName = 2;
   */
  userName = "";

  constructor(data?: PartialMessage<CreateTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.CreateTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "userPublicNkey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "userName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateTokenRequest {
    return new CreateTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateTokenRequest {
    return new CreateTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateTokenRequest {
    return new CreateTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateTokenRequest | PlainMessage<CreateTokenRequest> | undefined, b: CreateTokenRequest | PlainMessage<CreateTokenRequest> | undefined): boolean {
    return proto3.util.equals(CreateTokenRequest, a, b);
  }
}

/**
 * @generated from message account.CreateTokenResponse
 */
export class CreateTokenResponse extends Message<CreateTokenResponse> {
  /**
   * The JWT as a raw string
   *
   * @generated from field: string token = 1;
   */
  token = "";

  constructor(data?: PartialMessage<CreateTokenResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.CreateTokenResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateTokenResponse {
    return new CreateTokenResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateTokenResponse {
    return new CreateTokenResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateTokenResponse {
    return new CreateTokenResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateTokenResponse | PlainMessage<CreateTokenResponse> | undefined, b: CreateTokenResponse | PlainMessage<CreateTokenResponse> | undefined): boolean {
    return proto3.util.equals(CreateTokenResponse, a, b);
  }
}

/**
 * @generated from message account.RevlinkWarmupRequest
 */
export class RevlinkWarmupRequest extends Message<RevlinkWarmupRequest> {
  constructor(data?: PartialMessage<RevlinkWarmupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.RevlinkWarmupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RevlinkWarmupRequest {
    return new RevlinkWarmupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RevlinkWarmupRequest {
    return new RevlinkWarmupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RevlinkWarmupRequest {
    return new RevlinkWarmupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RevlinkWarmupRequest | PlainMessage<RevlinkWarmupRequest> | undefined, b: RevlinkWarmupRequest | PlainMessage<RevlinkWarmupRequest> | undefined): boolean {
    return proto3.util.equals(RevlinkWarmupRequest, a, b);
  }
}

/**
 * @generated from message account.RevlinkWarmupResponse
 */
export class RevlinkWarmupResponse extends Message<RevlinkWarmupResponse> {
  /**
   * @generated from field: string status = 1;
   */
  status = "";

  /**
   * @generated from field: int32 items = 2;
   */
  items = 0;

  /**
   * @generated from field: int32 edges = 3;
   */
  edges = 0;

  constructor(data?: PartialMessage<RevlinkWarmupResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.RevlinkWarmupResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "items", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "edges", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RevlinkWarmupResponse {
    return new RevlinkWarmupResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RevlinkWarmupResponse {
    return new RevlinkWarmupResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RevlinkWarmupResponse {
    return new RevlinkWarmupResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RevlinkWarmupResponse | PlainMessage<RevlinkWarmupResponse> | undefined, b: RevlinkWarmupResponse | PlainMessage<RevlinkWarmupResponse> | undefined): boolean {
    return proto3.util.equals(RevlinkWarmupResponse, a, b);
  }
}

/**
 * @generated from message account.GetTrialEndRequest
 */
export class GetTrialEndRequest extends Message<GetTrialEndRequest> {
  constructor(data?: PartialMessage<GetTrialEndRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.GetTrialEndRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTrialEndRequest {
    return new GetTrialEndRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTrialEndRequest {
    return new GetTrialEndRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTrialEndRequest {
    return new GetTrialEndRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetTrialEndRequest | PlainMessage<GetTrialEndRequest> | undefined, b: GetTrialEndRequest | PlainMessage<GetTrialEndRequest> | undefined): boolean {
    return proto3.util.equals(GetTrialEndRequest, a, b);
  }
}

/**
 * @generated from message account.GetTrialEndResponse
 */
export class GetTrialEndResponse extends Message<GetTrialEndResponse> {
  /**
   * @generated from field: google.protobuf.Timestamp endsAt = 1;
   */
  endsAt?: Timestamp;

  constructor(data?: PartialMessage<GetTrialEndResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.GetTrialEndResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "endsAt", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTrialEndResponse {
    return new GetTrialEndResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTrialEndResponse {
    return new GetTrialEndResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTrialEndResponse {
    return new GetTrialEndResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetTrialEndResponse | PlainMessage<GetTrialEndResponse> | undefined, b: GetTrialEndResponse | PlainMessage<GetTrialEndResponse> | undefined): boolean {
    return proto3.util.equals(GetTrialEndResponse, a, b);
  }
}

/**
 * @generated from message account.AvailableItemType
 */
export class AvailableItemType extends Message<AvailableItemType> {
  /**
   * The type of item that this adapter returns e.g. eks-cluster
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * The category that these items fall under
   *
   * @generated from field: account.AdapterCategory category = 2;
   */
  category = AdapterCategory.OTHER;

  /**
   * A descriptive name of the types of items that are returned by this
   * adapter e.g. "EKS Cluster"
   *
   * @generated from field: string descriptiveName = 3;
   */
  descriptiveName = "";

  constructor(data?: PartialMessage<AvailableItemType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.AvailableItemType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "category", kind: "enum", T: proto3.getEnumType(AdapterCategory) },
    { no: 3, name: "descriptiveName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AvailableItemType {
    return new AvailableItemType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AvailableItemType {
    return new AvailableItemType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AvailableItemType {
    return new AvailableItemType().fromJsonString(jsonString, options);
  }

  static equals(a: AvailableItemType | PlainMessage<AvailableItemType> | undefined, b: AvailableItemType | PlainMessage<AvailableItemType> | undefined): boolean {
    return proto3.util.equals(AvailableItemType, a, b);
  }
}

/**
 * @generated from message account.ListAvailableItemTypesRequest
 */
export class ListAvailableItemTypesRequest extends Message<ListAvailableItemTypesRequest> {
  constructor(data?: PartialMessage<ListAvailableItemTypesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.ListAvailableItemTypesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAvailableItemTypesRequest {
    return new ListAvailableItemTypesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAvailableItemTypesRequest {
    return new ListAvailableItemTypesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAvailableItemTypesRequest {
    return new ListAvailableItemTypesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAvailableItemTypesRequest | PlainMessage<ListAvailableItemTypesRequest> | undefined, b: ListAvailableItemTypesRequest | PlainMessage<ListAvailableItemTypesRequest> | undefined): boolean {
    return proto3.util.equals(ListAvailableItemTypesRequest, a, b);
  }
}

/**
 * @generated from message account.ListAvailableItemTypesResponse
 */
export class ListAvailableItemTypesResponse extends Message<ListAvailableItemTypesResponse> {
  /**
   * @generated from field: repeated account.AvailableItemType types = 1;
   */
  types: AvailableItemType[] = [];

  constructor(data?: PartialMessage<ListAvailableItemTypesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "account.ListAvailableItemTypesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "types", kind: "message", T: AvailableItemType, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAvailableItemTypesResponse {
    return new ListAvailableItemTypesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAvailableItemTypesResponse {
    return new ListAvailableItemTypesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAvailableItemTypesResponse {
    return new ListAvailableItemTypesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAvailableItemTypesResponse | PlainMessage<ListAvailableItemTypesResponse> | undefined, b: ListAvailableItemTypesResponse | PlainMessage<ListAvailableItemTypesResponse> | undefined): boolean {
    return proto3.util.equals(ListAvailableItemTypesResponse, a, b);
  }
}

