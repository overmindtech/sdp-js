// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file account.proto (package account, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { QueryMethod } from "./items_pb";
import { file_items } from "./items_pb";
import type { JsonObject, Message } from "@bufbuild/protobuf";

/**
 * Describes the file account.proto.
 */
export const file_account: GenFile = /*@__PURE__*/
  fileDesc("Cg1hY2NvdW50LnByb3RvEgdhY2NvdW50IhUKE0xpc3RBY2NvdW50c1JlcXVlc3QiOgoUTGlzdEFjY291bnRzUmVzcG9uc2USIgoIYWNjb3VudHMYASADKAsyEC5hY2NvdW50LkFjY291bnQiRgoUQ3JlYXRlQWNjb3VudFJlcXVlc3QSLgoKcHJvcGVydGllcxgBIAEoCzIaLmFjY291bnQuQWNjb3VudFByb3BlcnRpZXMiOgoVQ3JlYXRlQWNjb3VudFJlc3BvbnNlEiEKB2FjY291bnQYASABKAsyEC5hY2NvdW50LkFjY291bnQiRgoUVXBkYXRlQWNjb3VudFJlcXVlc3QSLgoKcHJvcGVydGllcxgBIAEoCzIaLmFjY291bnQuQWNjb3VudFByb3BlcnRpZXMiOgoVVXBkYXRlQWNjb3VudFJlc3BvbnNlEiEKB2FjY291bnQYASABKAsyEC5hY2NvdW50LkFjY291bnQiWQoZQWRtaW5VcGRhdGVBY2NvdW50UmVxdWVzdBIMCgRuYW1lGAEgASgJEi4KB3JlcXVlc3QYAiABKAsyHS5hY2NvdW50LlVwZGF0ZUFjY291bnRSZXF1ZXN0IiYKFkFkbWluR2V0QWNjb3VudFJlcXVlc3QSDAoEbmFtZRgBIAEoCSIpChlBZG1pbkRlbGV0ZUFjY291bnRSZXF1ZXN0EgwKBG5hbWUYASABKAkiHAoaQWRtaW5EZWxldGVBY2NvdW50UmVzcG9uc2UiWAoXQWRtaW5MaXN0U291cmNlc1JlcXVlc3QSDwoHYWNjb3VudBgBIAEoCRIsCgdyZXF1ZXN0GAIgASgLMhsuYWNjb3VudC5MaXN0U291cmNlc1JlcXVlc3QiWgoYQWRtaW5DcmVhdGVTb3VyY2VSZXF1ZXN0Eg8KB2FjY291bnQYASABKAkSLQoHcmVxdWVzdBgCIAEoCzIcLmFjY291bnQuQ3JlYXRlU291cmNlUmVxdWVzdCJUChVBZG1pbkdldFNvdXJjZVJlcXVlc3QSDwoHYWNjb3VudBgBIAEoCRIqCgdyZXF1ZXN0GAIgASgLMhkuYWNjb3VudC5HZXRTb3VyY2VSZXF1ZXN0IloKGEFkbWluVXBkYXRlU291cmNlUmVxdWVzdBIPCgdhY2NvdW50GAEgASgJEi0KB3JlcXVlc3QYAiABKAsyHC5hY2NvdW50LlVwZGF0ZVNvdXJjZVJlcXVlc3QiWgoYQWRtaW5EZWxldGVTb3VyY2VSZXF1ZXN0Eg8KB2FjY291bnQYASABKAkSLQoHcmVxdWVzdBgCIAEoCzIcLmFjY291bnQuRGVsZXRlU291cmNlUmVxdWVzdCJiChxBZG1pbktlZXBhbGl2ZVNvdXJjZXNSZXF1ZXN0Eg8KB2FjY291bnQYASABKAkSMQoHcmVxdWVzdBgCIAEoCzIgLmFjY291bnQuS2VlcGFsaXZlU291cmNlc1JlcXVlc3QiWAoXQWRtaW5DcmVhdGVUb2tlblJlcXVlc3QSDwoHYWNjb3VudBgBIAEoCRIsCgdyZXF1ZXN0GAIgASgLMhsuYWNjb3VudC5DcmVhdGVUb2tlblJlcXVlc3QiYgoGU291cmNlEikKCG1ldGFkYXRhGAEgASgLMhcuYWNjb3VudC5Tb3VyY2VNZXRhZGF0YRItCgpwcm9wZXJ0aWVzGAIgASgLMhkuYWNjb3VudC5Tb3VyY2VQcm9wZXJ0aWVzIqwBCg5Tb3VyY2VNZXRhZGF0YRIMCgRVVUlEGAEgASgMEhEKCVRva2VuTmFtZRgCIAEoCRIvCgtUb2tlbkV4cGlyeRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASEgoKUHVibGljTmtleRgFIAEoCRIlCgZTdGF0dXMYCSABKA4yFS5hY2NvdW50LlNvdXJjZVN0YXR1cxINCgVFcnJvchgKIAEoCSKVAQoQU291cmNlUHJvcGVydGllcxIXCg9EZXNjcmlwdGl2ZU5hbWUYASABKAkSDAoEVHlwZRgCIAEoCRInCgZDb25maWcYAyABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0EjEKEEFkZGl0aW9uYWxDb25maWcYBCABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0ImUKB0FjY291bnQSKgoIbWV0YWRhdGEYASABKAsyGC5hY2NvdW50LkFjY291bnRNZXRhZGF0YRIuCgpwcm9wZXJ0aWVzGAIgASgLMhouYWNjb3VudC5BY2NvdW50UHJvcGVydGllcyIlCg9BY2NvdW50TWV0YWRhdGESEgoKUHVibGljTmtleRgCIAEoCSI7ChFBY2NvdW50UHJvcGVydGllcxIMCgROYW1lGAEgASgJEhgKEFN0cmlwZUN1c3RvbWVySUQYAiABKAkiEwoRR2V0QWNjb3VudFJlcXVlc3QiNwoSR2V0QWNjb3VudFJlc3BvbnNlEiEKB2FjY291bnQYASABKAsyEC5hY2NvdW50LkFjY291bnQiJwoURGVsZXRlQWNjb3VudFJlcXVlc3QSDwoHaUFtU3VyZRgBIAEoCCIXChVEZWxldGVBY2NvdW50UmVzcG9uc2UiFAoSTGlzdFNvdXJjZXNSZXF1ZXN0IjcKE0xpc3RTb3VyY2VzUmVzcG9uc2USIAoHU291cmNlcxgBIAMoCzIPLmFjY291bnQuU291cmNlIkQKE0NyZWF0ZVNvdXJjZVJlcXVlc3QSLQoKcHJvcGVydGllcxgBIAEoCzIZLmFjY291bnQuU291cmNlUHJvcGVydGllcyI3ChRDcmVhdGVTb3VyY2VSZXNwb25zZRIfCgZzb3VyY2UYASABKAsyDy5hY2NvdW50LlNvdXJjZSIgChBHZXRTb3VyY2VSZXF1ZXN0EgwKBFVVSUQYASABKAwiNAoRR2V0U291cmNlUmVzcG9uc2USHwoGc291cmNlGAEgASgLMg8uYWNjb3VudC5Tb3VyY2UiUgoTVXBkYXRlU291cmNlUmVxdWVzdBIMCgRVVUlEGAEgASgMEi0KCnByb3BlcnRpZXMYAiABKAsyGS5hY2NvdW50LlNvdXJjZVByb3BlcnRpZXMiNwoUVXBkYXRlU291cmNlUmVzcG9uc2USHwoGc291cmNlGAEgASgLMg8uYWNjb3VudC5Tb3VyY2UiIwoTRGVsZXRlU291cmNlUmVxdWVzdBIMCgRVVUlEGAEgASgMIhYKFERlbGV0ZVNvdXJjZVJlc3BvbnNlIlsKFVNvdXJjZUtlZXBhbGl2ZVJlc3VsdBIMCgRVVUlEGAEgASgMEiUKBlN0YXR1cxgCIAEoDjIVLmFjY291bnQuU291cmNlU3RhdHVzEg0KBUVycm9yGAMgASgJIh0KG0xpc3RBbGxTb3VyY2VzU3RhdHVzUmVxdWVzdCKwAwoMU291cmNlSGVhbHRoEgwKBFVVSUQYASABKAwSDwoHdmVyc2lvbhgCIAEoCRIMCgRuYW1lGAMgASgJEhIKBWVycm9yGAQgASgJSACIAQESJQoGc3RhdHVzGAUgASgOMhUuYWNjb3VudC5Tb3VyY2VTdGF0dXMSLQoJY3JlYXRlZEF0GAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIxCg1sYXN0SGVhcnRiZWF0GAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIxCg1uZXh0SGVhcnRiZWF0GAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIMCgR0eXBlGAkgASgJEicKB21hbmFnZWQYCiABKA4yFi5hY2NvdW50LlNvdXJjZU1hbmFnZWQSFgoOYXZhaWxhYmxlVHlwZXMYCyADKAkSFwoPYXZhaWxhYmxlU2NvcGVzGAwgAygJEjEKD2FkYXB0ZXJNZXRhZGF0YRgNIAMoCzIYLmFjY291bnQuQWRhcHRlck1ldGFkYXRhQggKBl9lcnJvciJGChxMaXN0QWxsU291cmNlc1N0YXR1c1Jlc3BvbnNlEiYKB3NvdXJjZXMYASADKAsyFS5hY2NvdW50LlNvdXJjZUhlYWx0aCKnAgocU3VibWl0U291cmNlSGVhcnRiZWF0UmVxdWVzdBIMCgRVVUlEGAEgASgMEg8KB3ZlcnNpb24YAiABKAkSDAoEbmFtZRgDIAEoCRISCgVlcnJvchgEIAEoCUgAiAEBEjMKEG5leHRIZWFydGJlYXRNYXgYBSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SDAoEdHlwZRgGIAEoCRInCgdtYW5hZ2VkGAcgASgOMhYuYWNjb3VudC5Tb3VyY2VNYW5hZ2VkEhcKD2F2YWlsYWJsZVNjb3BlcxgJIAMoCRIxCg9hZGFwdGVyTWV0YWRhdGEYCiADKAsyGC5hY2NvdW50LkFkYXB0ZXJNZXRhZGF0YUIICgZfZXJyb3JKBAgIEAki+AEKD0FkYXB0ZXJNZXRhZGF0YRIMCgR0eXBlGAEgASgJEioKCGNhdGVnb3J5GAIgASgOMhguYWNjb3VudC5BZGFwdGVyQ2F0ZWdvcnkSFgoOcG90ZW50aWFsTGlua3MYAyADKAkSFwoPZGVzY3JpcHRpdmVOYW1lGAQgASgJEkQKFXN1cHBvcnRlZFF1ZXJ5TWV0aG9kcxgFIAEoCzIlLmFjY291bnQuQWRhcHRlclN1cHBvcnRlZFF1ZXJ5TWV0aG9kcxI0ChF0ZXJyYWZvcm1NYXBwaW5ncxgGIAMoCzIZLmFjY291bnQuVGVycmFmb3JtTWFwcGluZyKVAQocQWRhcHRlclN1cHBvcnRlZFF1ZXJ5TWV0aG9kcxILCgNnZXQYASABKAgSFgoOZ2V0RGVzY3JpcHRpb24YAiABKAkSDAoEbGlzdBgDIAEoCBIXCg9saXN0RGVzY3JpcHRpb24YBCABKAkSDgoGc2VhcmNoGAUgASgIEhkKEXNlYXJjaERlc2NyaXB0aW9uGAYgASgJIloKEFRlcnJhZm9ybU1hcHBpbmcSJQoPdGVycmFmb3JtTWV0aG9kGAEgASgOMgwuUXVlcnlNZXRob2QSGQoRdGVycmFmb3JtUXVlcnlNYXAYAiABKAlKBAgDEAQiHwodU3VibWl0U291cmNlSGVhcnRiZWF0UmVzcG9uc2UiMQoXS2VlcGFsaXZlU291cmNlc1JlcXVlc3QSFgoOd2FpdEZvckhlYWx0aHkYASABKAgiSwoYS2VlcGFsaXZlU291cmNlc1Jlc3BvbnNlEi8KB3NvdXJjZXMYASADKAsyHi5hY2NvdW50LlNvdXJjZUtlZXBhbGl2ZVJlc3VsdCI+ChJDcmVhdGVUb2tlblJlcXVlc3QSFgoOdXNlclB1YmxpY05rZXkYASABKAkSEAoIdXNlck5hbWUYAiABKAkiJAoTQ3JlYXRlVG9rZW5SZXNwb25zZRINCgV0b2tlbhgBIAEoCSIWChRSZXZsaW5rV2FybXVwUmVxdWVzdCJFChVSZXZsaW5rV2FybXVwUmVzcG9uc2USDgoGc3RhdHVzGAEgASgJEg0KBWl0ZW1zGAIgASgFEg0KBWVkZ2VzGAMgASgFIhQKEkdldFRyaWFsRW5kUmVxdWVzdCJBChNHZXRUcmlhbEVuZFJlc3BvbnNlEioKBmVuZHNBdBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiZgoRQXZhaWxhYmxlSXRlbVR5cGUSDAoEdHlwZRgBIAEoCRIqCghjYXRlZ29yeRgCIAEoDjIYLmFjY291bnQuQWRhcHRlckNhdGVnb3J5EhcKD2Rlc2NyaXB0aXZlTmFtZRgDIAEoCSIfCh1MaXN0QXZhaWxhYmxlSXRlbVR5cGVzUmVxdWVzdCJLCh5MaXN0QXZhaWxhYmxlSXRlbVR5cGVzUmVzcG9uc2USKQoFdHlwZXMYASADKAsyGi5hY2NvdW50LkF2YWlsYWJsZUl0ZW1UeXBlKpYBCgxTb3VyY2VTdGF0dXMSFgoSU1RBVFVTX1VOU1BFQ0lGSUVEEAASFgoSU1RBVFVTX1BST0dSRVNTSU5HEAESEgoOU1RBVFVTX0hFQUxUSFkQAhIUChBTVEFUVVNfVU5IRUFMVEhZEAMSEwoPU1RBVFVTX1NMRUVQSU5HEAQSFwoTU1RBVFVTX0RJU0NPTk5FQ1RFRBAFKicKDVNvdXJjZU1hbmFnZWQSCQoFTE9DQUwQABILCgdNQU5BR0VEEAEqsgIKD0FkYXB0ZXJDYXRlZ29yeRIaChZBREFQVEVSX0NBVEVHT1JZX09USEVSEAASKAokQURBUFRFUl9DQVRFR09SWV9DT01QVVRFX0FQUExJQ0FUSU9OEAESHAoYQURBUFRFUl9DQVRFR09SWV9TVE9SQUdFEAISHAoYQURBUFRFUl9DQVRFR09SWV9ORVRXT1JLEAMSHQoZQURBUFRFUl9DQVRFR09SWV9TRUNVUklUWRAEEiIKHkFEQVBURVJfQ0FURUdPUllfT0JTRVJWQUJJTElUWRAFEh0KGUFEQVBURVJfQ0FURUdPUllfREFUQUJBU0UQBhIiCh5BREFQVEVSX0NBVEVHT1JZX0NPTkZJR1VSQVRJT04QBxIXChNBREFQVEVSX0NBVEVHT1JZX0FJEAgy4QcKDEFkbWluU2VydmljZRJLCgxMaXN0QWNjb3VudHMSHC5hY2NvdW50Lkxpc3RBY2NvdW50c1JlcXVlc3QaHS5hY2NvdW50Lkxpc3RBY2NvdW50c1Jlc3BvbnNlEk4KDUNyZWF0ZUFjY291bnQSHS5hY2NvdW50LkNyZWF0ZUFjY291bnRSZXF1ZXN0Gh4uYWNjb3VudC5DcmVhdGVBY2NvdW50UmVzcG9uc2USUwoNVXBkYXRlQWNjb3VudBIiLmFjY291bnQuQWRtaW5VcGRhdGVBY2NvdW50UmVxdWVzdBoeLmFjY291bnQuVXBkYXRlQWNjb3VudFJlc3BvbnNlEkoKCkdldEFjY291bnQSHy5hY2NvdW50LkFkbWluR2V0QWNjb3VudFJlcXVlc3QaGy5hY2NvdW50LkdldEFjY291bnRSZXNwb25zZRJYCg1EZWxldGVBY2NvdW50EiIuYWNjb3VudC5BZG1pbkRlbGV0ZUFjY291bnRSZXF1ZXN0GiMuYWNjb3VudC5BZG1pbkRlbGV0ZUFjY291bnRSZXNwb25zZRJNCgtMaXN0U291cmNlcxIgLmFjY291bnQuQWRtaW5MaXN0U291cmNlc1JlcXVlc3QaHC5hY2NvdW50Lkxpc3RTb3VyY2VzUmVzcG9uc2USUAoMQ3JlYXRlU291cmNlEiEuYWNjb3VudC5BZG1pbkNyZWF0ZVNvdXJjZVJlcXVlc3QaHS5hY2NvdW50LkNyZWF0ZVNvdXJjZVJlc3BvbnNlEkcKCUdldFNvdXJjZRIeLmFjY291bnQuQWRtaW5HZXRTb3VyY2VSZXF1ZXN0GhouYWNjb3VudC5HZXRTb3VyY2VSZXNwb25zZRJQCgxVcGRhdGVTb3VyY2USIS5hY2NvdW50LkFkbWluVXBkYXRlU291cmNlUmVxdWVzdBodLmFjY291bnQuVXBkYXRlU291cmNlUmVzcG9uc2USUAoMRGVsZXRlU291cmNlEiEuYWNjb3VudC5BZG1pbkRlbGV0ZVNvdXJjZVJlcXVlc3QaHS5hY2NvdW50LkRlbGV0ZVNvdXJjZVJlc3BvbnNlElwKEEtlZXBhbGl2ZVNvdXJjZXMSJS5hY2NvdW50LkFkbWluS2VlcGFsaXZlU291cmNlc1JlcXVlc3QaIS5hY2NvdW50LktlZXBhbGl2ZVNvdXJjZXNSZXNwb25zZRJNCgtDcmVhdGVUb2tlbhIgLmFjY291bnQuQWRtaW5DcmVhdGVUb2tlblJlcXVlc3QaHC5hY2NvdW50LkNyZWF0ZVRva2VuUmVzcG9uc2Uy/gkKEU1hbmFnZW1lbnRTZXJ2aWNlEkUKCkdldEFjY291bnQSGi5hY2NvdW50LkdldEFjY291bnRSZXF1ZXN0GhsuYWNjb3VudC5HZXRBY2NvdW50UmVzcG9uc2USTgoNRGVsZXRlQWNjb3VudBIdLmFjY291bnQuRGVsZXRlQWNjb3VudFJlcXVlc3QaHi5hY2NvdW50LkRlbGV0ZUFjY291bnRSZXNwb25zZRJICgtMaXN0U291cmNlcxIbLmFjY291bnQuTGlzdFNvdXJjZXNSZXF1ZXN0GhwuYWNjb3VudC5MaXN0U291cmNlc1Jlc3BvbnNlEksKDENyZWF0ZVNvdXJjZRIcLmFjY291bnQuQ3JlYXRlU291cmNlUmVxdWVzdBodLmFjY291bnQuQ3JlYXRlU291cmNlUmVzcG9uc2USQgoJR2V0U291cmNlEhkuYWNjb3VudC5HZXRTb3VyY2VSZXF1ZXN0GhouYWNjb3VudC5HZXRTb3VyY2VSZXNwb25zZRJLCgxVcGRhdGVTb3VyY2USHC5hY2NvdW50LlVwZGF0ZVNvdXJjZVJlcXVlc3QaHS5hY2NvdW50LlVwZGF0ZVNvdXJjZVJlc3BvbnNlEksKDERlbGV0ZVNvdXJjZRIcLmFjY291bnQuRGVsZXRlU291cmNlUmVxdWVzdBodLmFjY291bnQuRGVsZXRlU291cmNlUmVzcG9uc2USYwoUTGlzdEFsbFNvdXJjZXNTdGF0dXMSJC5hY2NvdW50Lkxpc3RBbGxTb3VyY2VzU3RhdHVzUmVxdWVzdBolLmFjY291bnQuTGlzdEFsbFNvdXJjZXNTdGF0dXNSZXNwb25zZRJmChdMaXN0QWN0aXZlU291cmNlc1N0YXR1cxIkLmFjY291bnQuTGlzdEFsbFNvdXJjZXNTdGF0dXNSZXF1ZXN0GiUuYWNjb3VudC5MaXN0QWxsU291cmNlc1N0YXR1c1Jlc3BvbnNlEmYKFVN1Ym1pdFNvdXJjZUhlYXJ0YmVhdBIlLmFjY291bnQuU3VibWl0U291cmNlSGVhcnRiZWF0UmVxdWVzdBomLmFjY291bnQuU3VibWl0U291cmNlSGVhcnRiZWF0UmVzcG9uc2USVwoQS2VlcGFsaXZlU291cmNlcxIgLmFjY291bnQuS2VlcGFsaXZlU291cmNlc1JlcXVlc3QaIS5hY2NvdW50LktlZXBhbGl2ZVNvdXJjZXNSZXNwb25zZRJICgtDcmVhdGVUb2tlbhIbLmFjY291bnQuQ3JlYXRlVG9rZW5SZXF1ZXN0GhwuYWNjb3VudC5DcmVhdGVUb2tlblJlc3BvbnNlElAKDVJldmxpbmtXYXJtdXASHS5hY2NvdW50LlJldmxpbmtXYXJtdXBSZXF1ZXN0Gh4uYWNjb3VudC5SZXZsaW5rV2FybXVwUmVzcG9uc2UwARJICgtHZXRUcmlhbEVuZBIbLmFjY291bnQuR2V0VHJpYWxFbmRSZXF1ZXN0GhwuYWNjb3VudC5HZXRUcmlhbEVuZFJlc3BvbnNlEmkKFkxpc3RBdmFpbGFibGVJdGVtVHlwZXMSJi5hY2NvdW50Lkxpc3RBdmFpbGFibGVJdGVtVHlwZXNSZXF1ZXN0GicuYWNjb3VudC5MaXN0QXZhaWxhYmxlSXRlbVR5cGVzUmVzcG9uc2VCJFoiZ2l0aHViLmNvbS9vdmVybWluZHRlY2gvc2RwLWdvO3NkcGIGcHJvdG8z", [file_google_protobuf_duration, file_google_protobuf_struct, file_google_protobuf_timestamp, file_items]);

/**
 * @generated from message account.ListAccountsRequest
 */
export type ListAccountsRequest = Message<"account.ListAccountsRequest"> & {
};

/**
 * Describes the message account.ListAccountsRequest.
 * Use `create(ListAccountsRequestSchema)` to create a new message.
 */
export const ListAccountsRequestSchema: GenMessage<ListAccountsRequest> = /*@__PURE__*/
  messageDesc(file_account, 0);

/**
 * @generated from message account.ListAccountsResponse
 */
export type ListAccountsResponse = Message<"account.ListAccountsResponse"> & {
  /**
   * @generated from field: repeated account.Account accounts = 1;
   */
  accounts: Account[];
};

/**
 * Describes the message account.ListAccountsResponse.
 * Use `create(ListAccountsResponseSchema)` to create a new message.
 */
export const ListAccountsResponseSchema: GenMessage<ListAccountsResponse> = /*@__PURE__*/
  messageDesc(file_account, 1);

/**
 * @generated from message account.CreateAccountRequest
 */
export type CreateAccountRequest = Message<"account.CreateAccountRequest"> & {
  /**
   * @generated from field: account.AccountProperties properties = 1;
   */
  properties?: AccountProperties;
};

/**
 * Describes the message account.CreateAccountRequest.
 * Use `create(CreateAccountRequestSchema)` to create a new message.
 */
export const CreateAccountRequestSchema: GenMessage<CreateAccountRequest> = /*@__PURE__*/
  messageDesc(file_account, 2);

/**
 * @generated from message account.CreateAccountResponse
 */
export type CreateAccountResponse = Message<"account.CreateAccountResponse"> & {
  /**
   * @generated from field: account.Account account = 1;
   */
  account?: Account;
};

/**
 * Describes the message account.CreateAccountResponse.
 * Use `create(CreateAccountResponseSchema)` to create a new message.
 */
export const CreateAccountResponseSchema: GenMessage<CreateAccountResponse> = /*@__PURE__*/
  messageDesc(file_account, 3);

/**
 * @generated from message account.UpdateAccountRequest
 */
export type UpdateAccountRequest = Message<"account.UpdateAccountRequest"> & {
  /**
   * @generated from field: account.AccountProperties properties = 1;
   */
  properties?: AccountProperties;
};

/**
 * Describes the message account.UpdateAccountRequest.
 * Use `create(UpdateAccountRequestSchema)` to create a new message.
 */
export const UpdateAccountRequestSchema: GenMessage<UpdateAccountRequest> = /*@__PURE__*/
  messageDesc(file_account, 4);

/**
 * @generated from message account.UpdateAccountResponse
 */
export type UpdateAccountResponse = Message<"account.UpdateAccountResponse"> & {
  /**
   * @generated from field: account.Account account = 1;
   */
  account?: Account;
};

/**
 * Describes the message account.UpdateAccountResponse.
 * Use `create(UpdateAccountResponseSchema)` to create a new message.
 */
export const UpdateAccountResponseSchema: GenMessage<UpdateAccountResponse> = /*@__PURE__*/
  messageDesc(file_account, 5);

/**
 * @generated from message account.AdminUpdateAccountRequest
 */
export type AdminUpdateAccountRequest = Message<"account.AdminUpdateAccountRequest"> & {
  /**
   * The name of the account to update
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: account.UpdateAccountRequest request = 2;
   */
  request?: UpdateAccountRequest;
};

/**
 * Describes the message account.AdminUpdateAccountRequest.
 * Use `create(AdminUpdateAccountRequestSchema)` to create a new message.
 */
export const AdminUpdateAccountRequestSchema: GenMessage<AdminUpdateAccountRequest> = /*@__PURE__*/
  messageDesc(file_account, 6);

/**
 * @generated from message account.AdminGetAccountRequest
 */
export type AdminGetAccountRequest = Message<"account.AdminGetAccountRequest"> & {
  /**
   * The name of the account to get
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message account.AdminGetAccountRequest.
 * Use `create(AdminGetAccountRequestSchema)` to create a new message.
 */
export const AdminGetAccountRequestSchema: GenMessage<AdminGetAccountRequest> = /*@__PURE__*/
  messageDesc(file_account, 7);

/**
 * @generated from message account.AdminDeleteAccountRequest
 */
export type AdminDeleteAccountRequest = Message<"account.AdminDeleteAccountRequest"> & {
  /**
   * The name of the account to delete
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message account.AdminDeleteAccountRequest.
 * Use `create(AdminDeleteAccountRequestSchema)` to create a new message.
 */
export const AdminDeleteAccountRequestSchema: GenMessage<AdminDeleteAccountRequest> = /*@__PURE__*/
  messageDesc(file_account, 8);

/**
 * @generated from message account.AdminDeleteAccountResponse
 */
export type AdminDeleteAccountResponse = Message<"account.AdminDeleteAccountResponse"> & {
};

/**
 * Describes the message account.AdminDeleteAccountResponse.
 * Use `create(AdminDeleteAccountResponseSchema)` to create a new message.
 */
export const AdminDeleteAccountResponseSchema: GenMessage<AdminDeleteAccountResponse> = /*@__PURE__*/
  messageDesc(file_account, 9);

/**
 * @generated from message account.AdminListSourcesRequest
 */
export type AdminListSourcesRequest = Message<"account.AdminListSourcesRequest"> & {
  /**
   * @generated from field: string account = 1;
   */
  account: string;

  /**
   * @generated from field: account.ListSourcesRequest request = 2;
   */
  request?: ListSourcesRequest;
};

/**
 * Describes the message account.AdminListSourcesRequest.
 * Use `create(AdminListSourcesRequestSchema)` to create a new message.
 */
export const AdminListSourcesRequestSchema: GenMessage<AdminListSourcesRequest> = /*@__PURE__*/
  messageDesc(file_account, 10);

/**
 * @generated from message account.AdminCreateSourceRequest
 */
export type AdminCreateSourceRequest = Message<"account.AdminCreateSourceRequest"> & {
  /**
   * @generated from field: string account = 1;
   */
  account: string;

  /**
   * @generated from field: account.CreateSourceRequest request = 2;
   */
  request?: CreateSourceRequest;
};

/**
 * Describes the message account.AdminCreateSourceRequest.
 * Use `create(AdminCreateSourceRequestSchema)` to create a new message.
 */
export const AdminCreateSourceRequestSchema: GenMessage<AdminCreateSourceRequest> = /*@__PURE__*/
  messageDesc(file_account, 11);

/**
 * @generated from message account.AdminGetSourceRequest
 */
export type AdminGetSourceRequest = Message<"account.AdminGetSourceRequest"> & {
  /**
   * @generated from field: string account = 1;
   */
  account: string;

  /**
   * @generated from field: account.GetSourceRequest request = 2;
   */
  request?: GetSourceRequest;
};

/**
 * Describes the message account.AdminGetSourceRequest.
 * Use `create(AdminGetSourceRequestSchema)` to create a new message.
 */
export const AdminGetSourceRequestSchema: GenMessage<AdminGetSourceRequest> = /*@__PURE__*/
  messageDesc(file_account, 12);

/**
 * @generated from message account.AdminUpdateSourceRequest
 */
export type AdminUpdateSourceRequest = Message<"account.AdminUpdateSourceRequest"> & {
  /**
   * @generated from field: string account = 1;
   */
  account: string;

  /**
   * @generated from field: account.UpdateSourceRequest request = 2;
   */
  request?: UpdateSourceRequest;
};

/**
 * Describes the message account.AdminUpdateSourceRequest.
 * Use `create(AdminUpdateSourceRequestSchema)` to create a new message.
 */
export const AdminUpdateSourceRequestSchema: GenMessage<AdminUpdateSourceRequest> = /*@__PURE__*/
  messageDesc(file_account, 13);

/**
 * @generated from message account.AdminDeleteSourceRequest
 */
export type AdminDeleteSourceRequest = Message<"account.AdminDeleteSourceRequest"> & {
  /**
   * @generated from field: string account = 1;
   */
  account: string;

  /**
   * @generated from field: account.DeleteSourceRequest request = 2;
   */
  request?: DeleteSourceRequest;
};

/**
 * Describes the message account.AdminDeleteSourceRequest.
 * Use `create(AdminDeleteSourceRequestSchema)` to create a new message.
 */
export const AdminDeleteSourceRequestSchema: GenMessage<AdminDeleteSourceRequest> = /*@__PURE__*/
  messageDesc(file_account, 14);

/**
 * @generated from message account.AdminKeepaliveSourcesRequest
 */
export type AdminKeepaliveSourcesRequest = Message<"account.AdminKeepaliveSourcesRequest"> & {
  /**
   * @generated from field: string account = 1;
   */
  account: string;

  /**
   * @generated from field: account.KeepaliveSourcesRequest request = 2;
   */
  request?: KeepaliveSourcesRequest;
};

/**
 * Describes the message account.AdminKeepaliveSourcesRequest.
 * Use `create(AdminKeepaliveSourcesRequestSchema)` to create a new message.
 */
export const AdminKeepaliveSourcesRequestSchema: GenMessage<AdminKeepaliveSourcesRequest> = /*@__PURE__*/
  messageDesc(file_account, 15);

/**
 * @generated from message account.AdminCreateTokenRequest
 */
export type AdminCreateTokenRequest = Message<"account.AdminCreateTokenRequest"> & {
  /**
   * @generated from field: string account = 1;
   */
  account: string;

  /**
   * @generated from field: account.CreateTokenRequest request = 2;
   */
  request?: CreateTokenRequest;
};

/**
 * Describes the message account.AdminCreateTokenRequest.
 * Use `create(AdminCreateTokenRequestSchema)` to create a new message.
 */
export const AdminCreateTokenRequestSchema: GenMessage<AdminCreateTokenRequest> = /*@__PURE__*/
  messageDesc(file_account, 16);

/**
 * @generated from message account.Source
 */
export type Source = Message<"account.Source"> & {
  /**
   * @generated from field: account.SourceMetadata metadata = 1;
   */
  metadata?: SourceMetadata;

  /**
   * @generated from field: account.SourceProperties properties = 2;
   */
  properties?: SourceProperties;
};

/**
 * Describes the message account.Source.
 * Use `create(SourceSchema)` to create a new message.
 */
export const SourceSchema: GenMessage<Source> = /*@__PURE__*/
  messageDesc(file_account, 17);

/**
 * @generated from message account.SourceMetadata
 */
export type SourceMetadata = Message<"account.SourceMetadata"> & {
  /**
   * TODO: Change to ID along with everything else
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;

  /**
   * The name of the NATS JWT that has been generated for this source
   *
   * @generated from field: string TokenName = 2;
   */
  TokenName: string;

  /**
   * When the NATS JWT expires (unix time)
   *
   * @generated from field: google.protobuf.Timestamp TokenExpiry = 4;
   */
  TokenExpiry?: Timestamp;

  /**
   * The public NKey associated with the NATS JWT
   *
   * @generated from field: string PublicNkey = 5;
   */
  PublicNkey: string;

  /**
   * Status of the source
   *
   * @generated from field: account.SourceStatus Status = 9;
   */
  Status: SourceStatus;

  /**
   * The error message if the source is unhealthy
   *
   * @generated from field: string Error = 10;
   */
  Error: string;
};

/**
 * Describes the message account.SourceMetadata.
 * Use `create(SourceMetadataSchema)` to create a new message.
 */
export const SourceMetadataSchema: GenMessage<SourceMetadata> = /*@__PURE__*/
  messageDesc(file_account, 18);

/**
 * A source that is capable of discovering items
 *
 * @generated from message account.SourceProperties
 */
export type SourceProperties = Message<"account.SourceProperties"> & {
  /**
   * The descriptive name of the source
   *
   * @generated from field: string DescriptiveName = 1;
   */
  DescriptiveName: string;

  /**
   * What source to configure. Currently either "stdlib" or "aws"
   *
   * @generated from field: string Type = 2;
   */
  Type: string;

  /**
   * Config for this source. See the source documentation for what
   * source-specific config is available/required. This will be supplied
   * directly to viper via a config file at `/etc/srcman/config/source.yaml`
   *
   * @generated from field: google.protobuf.Struct Config = 3;
   */
  Config?: JsonObject;

  /**
   * Additional config options that should be passed to the source. The keys
   * of this object should be file names, and the values should be their
   * content. These files will be made available to the source at runtime.
   * Check the source's documentation for what to configure here if required
   *
   * @generated from field: google.protobuf.Struct AdditionalConfig = 4;
   */
  AdditionalConfig?: JsonObject;
};

/**
 * Describes the message account.SourceProperties.
 * Use `create(SourcePropertiesSchema)` to create a new message.
 */
export const SourcePropertiesSchema: GenMessage<SourceProperties> = /*@__PURE__*/
  messageDesc(file_account, 19);

/**
 * @generated from message account.Account
 */
export type Account = Message<"account.Account"> & {
  /**
   * @generated from field: account.AccountMetadata metadata = 1;
   */
  metadata?: AccountMetadata;

  /**
   * @generated from field: account.AccountProperties properties = 2;
   */
  properties?: AccountProperties;
};

/**
 * Describes the message account.Account.
 * Use `create(AccountSchema)` to create a new message.
 */
export const AccountSchema: GenMessage<Account> = /*@__PURE__*/
  messageDesc(file_account, 20);

/**
 * @generated from message account.AccountMetadata
 */
export type AccountMetadata = Message<"account.AccountMetadata"> & {
  /**
   * The public Nkey which signs all NATS "user" tokens
   *
   * @generated from field: string PublicNkey = 2;
   */
  PublicNkey: string;
};

/**
 * Describes the message account.AccountMetadata.
 * Use `create(AccountMetadataSchema)` to create a new message.
 */
export const AccountMetadataSchema: GenMessage<AccountMetadata> = /*@__PURE__*/
  messageDesc(file_account, 21);

/**
 * @generated from message account.AccountProperties
 */
export type AccountProperties = Message<"account.AccountProperties"> & {
  /**
   * The name of the account
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * The Customer ID within Stripe
   *
   * @generated from field: string StripeCustomerID = 2;
   */
  StripeCustomerID: string;
};

/**
 * Describes the message account.AccountProperties.
 * Use `create(AccountPropertiesSchema)` to create a new message.
 */
export const AccountPropertiesSchema: GenMessage<AccountProperties> = /*@__PURE__*/
  messageDesc(file_account, 22);

/**
 * @generated from message account.GetAccountRequest
 */
export type GetAccountRequest = Message<"account.GetAccountRequest"> & {
};

/**
 * Describes the message account.GetAccountRequest.
 * Use `create(GetAccountRequestSchema)` to create a new message.
 */
export const GetAccountRequestSchema: GenMessage<GetAccountRequest> = /*@__PURE__*/
  messageDesc(file_account, 23);

/**
 * @generated from message account.GetAccountResponse
 */
export type GetAccountResponse = Message<"account.GetAccountResponse"> & {
  /**
   * @generated from field: account.Account account = 1;
   */
  account?: Account;
};

/**
 * Describes the message account.GetAccountResponse.
 * Use `create(GetAccountResponseSchema)` to create a new message.
 */
export const GetAccountResponseSchema: GenMessage<GetAccountResponse> = /*@__PURE__*/
  messageDesc(file_account, 24);

/**
 * @generated from message account.DeleteAccountRequest
 */
export type DeleteAccountRequest = Message<"account.DeleteAccountRequest"> & {
  /**
   * Set to true to confirm that the user is sure they want to delete their
   * account. This is to prevent accidental deletions
   *
   * @generated from field: bool iAmSure = 1;
   */
  iAmSure: boolean;
};

/**
 * Describes the message account.DeleteAccountRequest.
 * Use `create(DeleteAccountRequestSchema)` to create a new message.
 */
export const DeleteAccountRequestSchema: GenMessage<DeleteAccountRequest> = /*@__PURE__*/
  messageDesc(file_account, 25);

/**
 * @generated from message account.DeleteAccountResponse
 */
export type DeleteAccountResponse = Message<"account.DeleteAccountResponse"> & {
};

/**
 * Describes the message account.DeleteAccountResponse.
 * Use `create(DeleteAccountResponseSchema)` to create a new message.
 */
export const DeleteAccountResponseSchema: GenMessage<DeleteAccountResponse> = /*@__PURE__*/
  messageDesc(file_account, 26);

/**
 * @generated from message account.ListSourcesRequest
 */
export type ListSourcesRequest = Message<"account.ListSourcesRequest"> & {
};

/**
 * Describes the message account.ListSourcesRequest.
 * Use `create(ListSourcesRequestSchema)` to create a new message.
 */
export const ListSourcesRequestSchema: GenMessage<ListSourcesRequest> = /*@__PURE__*/
  messageDesc(file_account, 27);

/**
 * @generated from message account.ListSourcesResponse
 */
export type ListSourcesResponse = Message<"account.ListSourcesResponse"> & {
  /**
   * @generated from field: repeated account.Source Sources = 1;
   */
  Sources: Source[];
};

/**
 * Describes the message account.ListSourcesResponse.
 * Use `create(ListSourcesResponseSchema)` to create a new message.
 */
export const ListSourcesResponseSchema: GenMessage<ListSourcesResponse> = /*@__PURE__*/
  messageDesc(file_account, 28);

/**
 * @generated from message account.CreateSourceRequest
 */
export type CreateSourceRequest = Message<"account.CreateSourceRequest"> & {
  /**
   * @generated from field: account.SourceProperties properties = 1;
   */
  properties?: SourceProperties;
};

/**
 * Describes the message account.CreateSourceRequest.
 * Use `create(CreateSourceRequestSchema)` to create a new message.
 */
export const CreateSourceRequestSchema: GenMessage<CreateSourceRequest> = /*@__PURE__*/
  messageDesc(file_account, 29);

/**
 * @generated from message account.CreateSourceResponse
 */
export type CreateSourceResponse = Message<"account.CreateSourceResponse"> & {
  /**
   * @generated from field: account.Source source = 1;
   */
  source?: Source;
};

/**
 * Describes the message account.CreateSourceResponse.
 * Use `create(CreateSourceResponseSchema)` to create a new message.
 */
export const CreateSourceResponseSchema: GenMessage<CreateSourceResponse> = /*@__PURE__*/
  messageDesc(file_account, 30);

/**
 * @generated from message account.GetSourceRequest
 */
export type GetSourceRequest = Message<"account.GetSourceRequest"> & {
  /**
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;
};

/**
 * Describes the message account.GetSourceRequest.
 * Use `create(GetSourceRequestSchema)` to create a new message.
 */
export const GetSourceRequestSchema: GenMessage<GetSourceRequest> = /*@__PURE__*/
  messageDesc(file_account, 31);

/**
 * @generated from message account.GetSourceResponse
 */
export type GetSourceResponse = Message<"account.GetSourceResponse"> & {
  /**
   * @generated from field: account.Source source = 1;
   */
  source?: Source;
};

/**
 * Describes the message account.GetSourceResponse.
 * Use `create(GetSourceResponseSchema)` to create a new message.
 */
export const GetSourceResponseSchema: GenMessage<GetSourceResponse> = /*@__PURE__*/
  messageDesc(file_account, 32);

/**
 * @generated from message account.UpdateSourceRequest
 */
export type UpdateSourceRequest = Message<"account.UpdateSourceRequest"> & {
  /**
   * ID of the source to update
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;

  /**
   * Properties to update
   *
   * @generated from field: account.SourceProperties properties = 2;
   */
  properties?: SourceProperties;
};

/**
 * Describes the message account.UpdateSourceRequest.
 * Use `create(UpdateSourceRequestSchema)` to create a new message.
 */
export const UpdateSourceRequestSchema: GenMessage<UpdateSourceRequest> = /*@__PURE__*/
  messageDesc(file_account, 33);

/**
 * @generated from message account.UpdateSourceResponse
 */
export type UpdateSourceResponse = Message<"account.UpdateSourceResponse"> & {
  /**
   * @generated from field: account.Source source = 1;
   */
  source?: Source;
};

/**
 * Describes the message account.UpdateSourceResponse.
 * Use `create(UpdateSourceResponseSchema)` to create a new message.
 */
export const UpdateSourceResponseSchema: GenMessage<UpdateSourceResponse> = /*@__PURE__*/
  messageDesc(file_account, 34);

/**
 * @generated from message account.DeleteSourceRequest
 */
export type DeleteSourceRequest = Message<"account.DeleteSourceRequest"> & {
  /**
   * ID if the source to delete
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;
};

/**
 * Describes the message account.DeleteSourceRequest.
 * Use `create(DeleteSourceRequestSchema)` to create a new message.
 */
export const DeleteSourceRequestSchema: GenMessage<DeleteSourceRequest> = /*@__PURE__*/
  messageDesc(file_account, 35);

/**
 * @generated from message account.DeleteSourceResponse
 */
export type DeleteSourceResponse = Message<"account.DeleteSourceResponse"> & {
};

/**
 * Describes the message account.DeleteSourceResponse.
 * Use `create(DeleteSourceResponseSchema)` to create a new message.
 */
export const DeleteSourceResponseSchema: GenMessage<DeleteSourceResponse> = /*@__PURE__*/
  messageDesc(file_account, 36);

/**
 * @generated from message account.SourceKeepaliveResult
 */
export type SourceKeepaliveResult = Message<"account.SourceKeepaliveResult"> & {
  /**
   * The UUID of the source that was kept alive
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;

  /**
   * The status of the source
   *
   * @generated from field: account.SourceStatus Status = 2;
   */
  Status: SourceStatus;

  /**
   * The error message if the source is unhealthy
   *
   * @generated from field: string Error = 3;
   */
  Error: string;
};

/**
 * Describes the message account.SourceKeepaliveResult.
 * Use `create(SourceKeepaliveResultSchema)` to create a new message.
 */
export const SourceKeepaliveResultSchema: GenMessage<SourceKeepaliveResult> = /*@__PURE__*/
  messageDesc(file_account, 37);

/**
 * @generated from message account.ListAllSourcesStatusRequest
 */
export type ListAllSourcesStatusRequest = Message<"account.ListAllSourcesStatusRequest"> & {
};

/**
 * Describes the message account.ListAllSourcesStatusRequest.
 * Use `create(ListAllSourcesStatusRequestSchema)` to create a new message.
 */
export const ListAllSourcesStatusRequestSchema: GenMessage<ListAllSourcesStatusRequest> = /*@__PURE__*/
  messageDesc(file_account, 38);

/**
 * @generated from message account.SourceHealth
 */
export type SourceHealth = Message<"account.SourceHealth"> & {
  /**
   * The UUID of the source
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;

  /**
   * The version of the source
   *
   * @generated from field: string version = 2;
   */
  version: string;

  /**
   * The name of the source
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * The error message if the source is unhealthy
   *
   * @generated from field: optional string error = 4;
   */
  error?: string;

  /**
   * The status of the source, this is calculated based on the last heartbeat received and if there is an error
   *
   * @generated from field: account.SourceStatus status = 5;
   */
  status: SourceStatus;

  /**
   * Created at time
   *
   * @generated from field: google.protobuf.Timestamp createdAt = 6;
   */
  createdAt?: Timestamp;

  /**
   * The last time we received a heartbeat from the source
   *
   * @generated from field: google.protobuf.Timestamp lastHeartbeat = 7;
   */
  lastHeartbeat?: Timestamp;

  /**
   * The next time we expect to receive a heartbeat from the source
   *
   * @generated from field: google.protobuf.Timestamp nextHeartbeat = 8;
   */
  nextHeartbeat?: Timestamp;

  /**
   * The type of the source, AWS or Stdlib or Kubernetes
   *
   * @generated from field: string type = 9;
   */
  type: string;

  /**
   * Whether the source is managed, or local
   *
   * @generated from field: account.SourceManaged managed = 10;
   */
  managed: SourceManaged;

  /**
   * The types of sources that this source can discover
   *
   * @generated from field: repeated string availableTypes = 11;
   */
  availableTypes: string[];

  /**
   * The scopes that this source can discover
   *
   * @generated from field: repeated string availableScopes = 12;
   */
  availableScopes: string[];

  /**
   * AdapterMetadata is a map of metadata that the source can send to the API
   *
   * @generated from field: repeated account.AdapterMetadata adapterMetadata = 13;
   */
  adapterMetadata: AdapterMetadata[];
};

/**
 * Describes the message account.SourceHealth.
 * Use `create(SourceHealthSchema)` to create a new message.
 */
export const SourceHealthSchema: GenMessage<SourceHealth> = /*@__PURE__*/
  messageDesc(file_account, 39);

/**
 * @generated from message account.ListAllSourcesStatusResponse
 */
export type ListAllSourcesStatusResponse = Message<"account.ListAllSourcesStatusResponse"> & {
  /**
   * @generated from field: repeated account.SourceHealth sources = 1;
   */
  sources: SourceHealth[];
};

/**
 * Describes the message account.ListAllSourcesStatusResponse.
 * Use `create(ListAllSourcesStatusResponseSchema)` to create a new message.
 */
export const ListAllSourcesStatusResponseSchema: GenMessage<ListAllSourcesStatusResponse> = /*@__PURE__*/
  messageDesc(file_account, 40);

/**
 * The source sends a heartbeat to the API to let it know that it is still alive, note it does not give a status.
 *
 * @generated from message account.SubmitSourceHeartbeatRequest
 */
export type SubmitSourceHeartbeatRequest = Message<"account.SubmitSourceHeartbeatRequest"> & {
  /**
   * The UUID of the source that is sending the heartbeat
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;

  /**
   * The version of the source
   *
   * @generated from field: string version = 2;
   */
  version: string;

  /**
   * The name of the source
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * The error message if the source is unhealthy
   *
   * @generated from field: optional string error = 4;
   */
  error?: string;

  /**
   * The maximum time between heartbeats that the source can send to the api-server. Otherwise, the source will be marked as unhealthy. eg 30s
   *
   * @generated from field: google.protobuf.Duration nextHeartbeatMax = 5;
   */
  nextHeartbeatMax?: Duration;

  /**
   * The type of the source, AWS or Stdlib or Kubernetes
   *
   * @generated from field: string type = 6;
   */
  type: string;

  /**
   * Whether the source is managed, or local
   *
   * @generated from field: account.SourceManaged managed = 7;
   */
  managed: SourceManaged;

  /**
   * The scopes that this source can discover
   *
   * @generated from field: repeated string availableScopes = 9;
   */
  availableScopes: string[];

  /**
   * AdapterMetadata is a map of metadata that the source can send to the API
   *
   * @generated from field: repeated account.AdapterMetadata adapterMetadata = 10;
   */
  adapterMetadata: AdapterMetadata[];
};

/**
 * Describes the message account.SubmitSourceHeartbeatRequest.
 * Use `create(SubmitSourceHeartbeatRequestSchema)` to create a new message.
 */
export const SubmitSourceHeartbeatRequestSchema: GenMessage<SubmitSourceHeartbeatRequest> = /*@__PURE__*/
  messageDesc(file_account, 41);

/**
 * @generated from message account.AdapterMetadata
 */
export type AdapterMetadata = Message<"account.AdapterMetadata"> & {
  /**
   * The type of item that this adapter returns e.g. eks-cluster
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * The category that these items fall under
   *
   * @generated from field: account.AdapterCategory category = 2;
   */
  category: AdapterCategory;

  /**
   * The list of other types that this can be linked to, eg eks-cluster ->
   * eks-node-group
   *
   * @generated from field: repeated string potentialLinks = 3;
   */
  potentialLinks: string[];

  /**
   * A descriptive name of the types of items that are returned by this
   * adapter e.g. "EKS Cluster"
   *
   * @generated from field: string descriptiveName = 4;
   */
  descriptiveName: string;

  /**
   * The supported query methods for this adapter
   *
   * @generated from field: account.AdapterSupportedQueryMethods supportedQueryMethods = 5;
   */
  supportedQueryMethods?: AdapterSupportedQueryMethods;

  /**
   * The terraform mappings for this adapter, this is optional
   *
   * @generated from field: repeated account.TerraformMapping terraformMappings = 6;
   */
  terraformMappings: TerraformMapping[];
};

/**
 * Describes the message account.AdapterMetadata.
 * Use `create(AdapterMetadataSchema)` to create a new message.
 */
export const AdapterMetadataSchema: GenMessage<AdapterMetadata> = /*@__PURE__*/
  messageDesc(file_account, 42);

/**
 * The methods that this adapter supports, and the description of how to use
 * them
 *
 * @generated from message account.AdapterSupportedQueryMethods
 */
export type AdapterSupportedQueryMethods = Message<"account.AdapterSupportedQueryMethods"> & {
  /**
   * Whether or not the GET method is supported
   *
   * @generated from field: bool get = 1;
   */
  get: boolean;

  /**
   * Description of the query that should be passed to the GET method
   *
   * @generated from field: string getDescription = 2;
   */
  getDescription: string;

  /**
   * Whether or not the LIST method is supported
   *
   * @generated from field: bool list = 3;
   */
  list: boolean;

  /**
   * Description of how the LIST method works
   *
   * @generated from field: string listDescription = 4;
   */
  listDescription: string;

  /**
   * Whether or not the SEARCH method is supported
   *
   * @generated from field: bool search = 5;
   */
  search: boolean;

  /**
   * Description of the query that should be passed to the SEARCH method
   *
   * @generated from field: string searchDescription = 6;
   */
  searchDescription: string;
};

/**
 * Describes the message account.AdapterSupportedQueryMethods.
 * Use `create(AdapterSupportedQueryMethodsSchema)` to create a new message.
 */
export const AdapterSupportedQueryMethodsSchema: GenMessage<AdapterSupportedQueryMethods> = /*@__PURE__*/
  messageDesc(file_account, 43);

/**
 * When Overmind ingests Terraform changes, it needs to be able to map from a
 * given Terraform resource, to that same resource in Overmind. This is achieved
 * by using the TerraformMapping object. It translates the details of a Terraform
 * resource into a query that Overmind can run.
 *
 * NOTE: The queries that are generated by this mapping use the wildcard scope
 * `*` and therefore could return multiple items. Overmind will compare the
 * attributes of these items to determine the most likely candidate for a mch
 * and select that.
 *
 * @generated from message account.TerraformMapping
 */
export type TerraformMapping = Message<"account.TerraformMapping"> & {
  /**
   * The method that the query should use
   *
   * @generated from field: QueryMethod terraformMethod = 1;
   */
  terraformMethod: QueryMethod;

  /**
   * How to map data from the terraform resource to the "query" field in the
   * resulting mapping query. This uses HCL syntax  e.g.
   * resource_type.attribute_name
   *
   * Usually this will be the attribute that uniquely identifies the resource
   * such as `aws_instance.id` or `aws_iam_role.arn`. You can also index into
   * arrays e.g. `kubernetes_replication_controller.metadata[0].name`
   *
   * @generated from field: string terraformQueryMap = 2;
   */
  terraformQueryMap: string;
};

/**
 * Describes the message account.TerraformMapping.
 * Use `create(TerraformMappingSchema)` to create a new message.
 */
export const TerraformMappingSchema: GenMessage<TerraformMapping> = /*@__PURE__*/
  messageDesc(file_account, 44);

/**
 * @generated from message account.SubmitSourceHeartbeatResponse
 */
export type SubmitSourceHeartbeatResponse = Message<"account.SubmitSourceHeartbeatResponse"> & {
};

/**
 * Describes the message account.SubmitSourceHeartbeatResponse.
 * Use `create(SubmitSourceHeartbeatResponseSchema)` to create a new message.
 */
export const SubmitSourceHeartbeatResponseSchema: GenMessage<SubmitSourceHeartbeatResponse> = /*@__PURE__*/
  messageDesc(file_account, 45);

/**
 * @generated from message account.KeepaliveSourcesRequest
 */
export type KeepaliveSourcesRequest = Message<"account.KeepaliveSourcesRequest"> & {
  /**
   * Set to true to have the API call wait until the source is up and healthy
   *
   * @generated from field: bool waitForHealthy = 1;
   */
  waitForHealthy: boolean;
};

/**
 * Describes the message account.KeepaliveSourcesRequest.
 * Use `create(KeepaliveSourcesRequestSchema)` to create a new message.
 */
export const KeepaliveSourcesRequestSchema: GenMessage<KeepaliveSourcesRequest> = /*@__PURE__*/
  messageDesc(file_account, 46);

/**
 * @generated from message account.KeepaliveSourcesResponse
 */
export type KeepaliveSourcesResponse = Message<"account.KeepaliveSourcesResponse"> & {
  /**
   * If the user requested to wait for the sources to be healthy, this will
   * contain information about the sources that came up. If the user did not
   * request to wait, this will be empty
   *
   * @generated from field: repeated account.SourceKeepaliveResult sources = 1;
   */
  sources: SourceKeepaliveResult[];
};

/**
 * Describes the message account.KeepaliveSourcesResponse.
 * Use `create(KeepaliveSourcesResponseSchema)` to create a new message.
 */
export const KeepaliveSourcesResponseSchema: GenMessage<KeepaliveSourcesResponse> = /*@__PURE__*/
  messageDesc(file_account, 47);

/**
 * @generated from message account.CreateTokenRequest
 */
export type CreateTokenRequest = Message<"account.CreateTokenRequest"> & {
  /**
   * The Public NKey of the user that is requesting a token
   *
   * @generated from field: string userPublicNkey = 1;
   */
  userPublicNkey: string;

  /**
   * Friendly user name
   *
   * @generated from field: string userName = 2;
   */
  userName: string;
};

/**
 * Describes the message account.CreateTokenRequest.
 * Use `create(CreateTokenRequestSchema)` to create a new message.
 */
export const CreateTokenRequestSchema: GenMessage<CreateTokenRequest> = /*@__PURE__*/
  messageDesc(file_account, 48);

/**
 * @generated from message account.CreateTokenResponse
 */
export type CreateTokenResponse = Message<"account.CreateTokenResponse"> & {
  /**
   * The JWT as a raw string
   *
   * @generated from field: string token = 1;
   */
  token: string;
};

/**
 * Describes the message account.CreateTokenResponse.
 * Use `create(CreateTokenResponseSchema)` to create a new message.
 */
export const CreateTokenResponseSchema: GenMessage<CreateTokenResponse> = /*@__PURE__*/
  messageDesc(file_account, 49);

/**
 * @generated from message account.RevlinkWarmupRequest
 */
export type RevlinkWarmupRequest = Message<"account.RevlinkWarmupRequest"> & {
};

/**
 * Describes the message account.RevlinkWarmupRequest.
 * Use `create(RevlinkWarmupRequestSchema)` to create a new message.
 */
export const RevlinkWarmupRequestSchema: GenMessage<RevlinkWarmupRequest> = /*@__PURE__*/
  messageDesc(file_account, 50);

/**
 * @generated from message account.RevlinkWarmupResponse
 */
export type RevlinkWarmupResponse = Message<"account.RevlinkWarmupResponse"> & {
  /**
   * @generated from field: string status = 1;
   */
  status: string;

  /**
   * @generated from field: int32 items = 2;
   */
  items: number;

  /**
   * @generated from field: int32 edges = 3;
   */
  edges: number;
};

/**
 * Describes the message account.RevlinkWarmupResponse.
 * Use `create(RevlinkWarmupResponseSchema)` to create a new message.
 */
export const RevlinkWarmupResponseSchema: GenMessage<RevlinkWarmupResponse> = /*@__PURE__*/
  messageDesc(file_account, 51);

/**
 * @generated from message account.GetTrialEndRequest
 */
export type GetTrialEndRequest = Message<"account.GetTrialEndRequest"> & {
};

/**
 * Describes the message account.GetTrialEndRequest.
 * Use `create(GetTrialEndRequestSchema)` to create a new message.
 */
export const GetTrialEndRequestSchema: GenMessage<GetTrialEndRequest> = /*@__PURE__*/
  messageDesc(file_account, 52);

/**
 * @generated from message account.GetTrialEndResponse
 */
export type GetTrialEndResponse = Message<"account.GetTrialEndResponse"> & {
  /**
   * @generated from field: google.protobuf.Timestamp endsAt = 1;
   */
  endsAt?: Timestamp;
};

/**
 * Describes the message account.GetTrialEndResponse.
 * Use `create(GetTrialEndResponseSchema)` to create a new message.
 */
export const GetTrialEndResponseSchema: GenMessage<GetTrialEndResponse> = /*@__PURE__*/
  messageDesc(file_account, 53);

/**
 * @generated from message account.AvailableItemType
 */
export type AvailableItemType = Message<"account.AvailableItemType"> & {
  /**
   * The type of item that this adapter returns e.g. eks-cluster
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * The category that these items fall under
   *
   * @generated from field: account.AdapterCategory category = 2;
   */
  category: AdapterCategory;

  /**
   * A descriptive name of the types of items that are returned by this
   * adapter e.g. "EKS Cluster"
   *
   * @generated from field: string descriptiveName = 3;
   */
  descriptiveName: string;
};

/**
 * Describes the message account.AvailableItemType.
 * Use `create(AvailableItemTypeSchema)` to create a new message.
 */
export const AvailableItemTypeSchema: GenMessage<AvailableItemType> = /*@__PURE__*/
  messageDesc(file_account, 54);

/**
 * @generated from message account.ListAvailableItemTypesRequest
 */
export type ListAvailableItemTypesRequest = Message<"account.ListAvailableItemTypesRequest"> & {
};

/**
 * Describes the message account.ListAvailableItemTypesRequest.
 * Use `create(ListAvailableItemTypesRequestSchema)` to create a new message.
 */
export const ListAvailableItemTypesRequestSchema: GenMessage<ListAvailableItemTypesRequest> = /*@__PURE__*/
  messageDesc(file_account, 55);

/**
 * @generated from message account.ListAvailableItemTypesResponse
 */
export type ListAvailableItemTypesResponse = Message<"account.ListAvailableItemTypesResponse"> & {
  /**
   * @generated from field: repeated account.AvailableItemType types = 1;
   */
  types: AvailableItemType[];
};

/**
 * Describes the message account.ListAvailableItemTypesResponse.
 * Use `create(ListAvailableItemTypesResponseSchema)` to create a new message.
 */
export const ListAvailableItemTypesResponseSchema: GenMessage<ListAvailableItemTypesResponse> = /*@__PURE__*/
  messageDesc(file_account, 56);

/**
 * @generated from enum account.SourceStatus
 */
export enum SourceStatus {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * The source is starting or updating. This is only applicable to managed
   * sources where Overmind manages the source's lifecycle
   *
   * @generated from enum value: STATUS_PROGRESSING = 1;
   */
  STATUS_PROGRESSING = 1,

  /**
   * The source is healthy
   *
   * @generated from enum value: STATUS_HEALTHY = 2;
   */
  STATUS_HEALTHY = 2,

  /**
   * The source is unhealthy
   *
   * @generated from enum value: STATUS_UNHEALTHY = 3;
   */
  STATUS_UNHEALTHY = 3,

  /**
   * The source is sleeping due to inactivity. It will be woken up before it
   * is needed. This is only applicable to managed sources where Overmind
   * manages the source's lifecycle
   *
   * @generated from enum value: STATUS_SLEEPING = 4;
   */
  STATUS_SLEEPING = 4,

  /**
   * The source is disconnected and therefore not able to handle requests.
   * This will only be returned for non-managed sources that have recently
   * stopped sending heartbeats such as a user running the CLI that has
   * recently disconnected
   *
   * @generated from enum value: STATUS_DISCONNECTED = 5;
   */
  STATUS_DISCONNECTED = 5,
}

/**
 * Describes the enum account.SourceStatus.
 */
export const SourceStatusSchema: GenEnum<SourceStatus> = /*@__PURE__*/
  enumDesc(file_account, 0);

/**
 * Whether the source is managed by srcman or was created by the user locally
 *
 * @generated from enum account.SourceManaged
 */
export enum SourceManaged {
  /**
   * Local is the default
   *
   * @generated from enum value: LOCAL = 0;
   */
  LOCAL = 0,

  /**
   * @generated from enum value: MANAGED = 1;
   */
  MANAGED = 1,
}

/**
 * Describes the enum account.SourceManaged.
 */
export const SourceManagedSchema: GenEnum<SourceManaged> = /*@__PURE__*/
  enumDesc(file_account, 1);

/**
 * @generated from enum account.AdapterCategory
 */
export enum AdapterCategory {
  /**
   * Fall-back category for resources that do not fit into any other category
   *
   * @generated from enum value: ADAPTER_CATEGORY_OTHER = 0;
   */
  OTHER = 0,

  /**
   * This category includes resources that provide processing power and host
   * applications or services. Examples are virtual machines, containers,
   * serverless functions, and application hosting platforms. If the primary
   * purpose of a resource is to execute workloads, run code, or host
   * applications, it should belong here.
   *
   * @generated from enum value: ADAPTER_CATEGORY_COMPUTE_APPLICATION = 1;
   */
  COMPUTE_APPLICATION = 1,

  /**
   * Encompassing resources designed to store, archive, and manage data, this
   * category includes object storage, block storage, file storage, and data
   * backup solutions. Select this category when the core function of a
   * resource is persistent data storage or management
   *
   * @generated from enum value: ADAPTER_CATEGORY_STORAGE = 2;
   */
  STORAGE = 2,

  /**
   * This category covers resources that facilitate connectivity and
   * communication within cloud environments. Typical resources include
   * virtual networks, load balancers, VPNs, and DNS services. Assign
   * resources here if their primary role is related to communication,
   * connectivity, or traffic management
   *
   * @generated from enum value: ADAPTER_CATEGORY_NETWORK = 3;
   */
  NETWORK = 3,

  /**
   * Resources in this category focus on safeguarding data, applications, and
   * cloud infrastructure. Examples include firewalls, identity and access
   * management, encryption services, and security monitoring tools. Choose
   * this category if a resource's main function is security, access control,
   * or compliance
   *
   * @generated from enum value: ADAPTER_CATEGORY_SECURITY = 4;
   */
  SECURITY = 4,

  /**
   * This category includes resources aimed at monitoring, tracing, and
   * logging applications and cloud infrastructure. Examples are monitoring
   * tools, logging services, and performance management solutions. Use this
   * category for resources that provide insights into system performance and
   * health
   *
   * @generated from enum value: ADAPTER_CATEGORY_OBSERVABILITY = 5;
   */
  OBSERVABILITY = 5,

  /**
   * Focused on structured data storage and management, this category includes
   * relational, NoSQL, and in-memory databases, along with data warehousing
   * solutions. Choose this category for resources specifically designed for
   * data querying, transaction processing, or complex data operations. This
   * differs from "storage" in that "databases" have compute associated with
   * them rather than just storing data.
   *
   * @generated from enum value: ADAPTER_CATEGORY_DATABASE = 6;
   */
  DATABASE = 6,

  /**
   * This category includes resources designed for managing configurations and
   * deployments. Examples are infrastructure as code tools, configuration
   * management services, and deployment orchestration solutions. Classify
   * resources here if they primarily handle configuration, environment
   * management, or automated deployment
   *
   * @generated from enum value: ADAPTER_CATEGORY_CONFIGURATION = 7;
   */
  CONFIGURATION = 7,

  /**
   * This category is dedicated to resources for developing, training, and
   * deploying artificial intelligence models and machine learning
   * applications. Include machine learning platforms, AI services, and data
   * labeling tools here. Select this category if a resource's principal
   * function involves AI or machine learning processes
   *
   * @generated from enum value: ADAPTER_CATEGORY_AI = 8;
   */
  AI = 8,
}

/**
 * Describes the enum account.AdapterCategory.
 */
export const AdapterCategorySchema: GenEnum<AdapterCategory> = /*@__PURE__*/
  enumDesc(file_account, 2);

/**
 * The admin service allows users with Admin privileges to any account. Many of
 * the RPCs in this service mirror RPCs in the ManagementService, but allow the
 * user to specify an account to operate on, rather than using the account that
 * the user belongs to.
 *
 * @generated from service account.AdminService
 */
export const AdminService: GenService<{
  /**
   * Lists the details of all NATS Accounts
   *
   * @generated from rpc account.AdminService.ListAccounts
   */
  listAccounts: {
    methodKind: "unary";
    input: typeof ListAccountsRequestSchema;
    output: typeof ListAccountsResponseSchema;
  },
  /**
   * Creates a new account, public_nkey will be autogenerated
   *
   * @generated from rpc account.AdminService.CreateAccount
   */
  createAccount: {
    methodKind: "unary";
    input: typeof CreateAccountRequestSchema;
    output: typeof CreateAccountResponseSchema;
  },
  /**
   * Updates account details, returns the account
   *
   * @generated from rpc account.AdminService.UpdateAccount
   */
  updateAccount: {
    methodKind: "unary";
    input: typeof AdminUpdateAccountRequestSchema;
    output: typeof UpdateAccountResponseSchema;
  },
  /**
   * Get the details of a given account
   *
   * @generated from rpc account.AdminService.GetAccount
   */
  getAccount: {
    methodKind: "unary";
    input: typeof AdminGetAccountRequestSchema;
    output: typeof GetAccountResponseSchema;
  },
  /**
   * Completely deletes an account. This includes all of the data in that
   * account, bookmarks, changes etc. It also deletes all users from Auth0
   * that are associated with this account
   *
   * @generated from rpc account.AdminService.DeleteAccount
   */
  deleteAccount: {
    methodKind: "unary";
    input: typeof AdminDeleteAccountRequestSchema;
    output: typeof AdminDeleteAccountResponseSchema;
  },
  /**
   * Lists all sources within the chosen account
   *
   * @generated from rpc account.AdminService.ListSources
   */
  listSources: {
    methodKind: "unary";
    input: typeof AdminListSourcesRequestSchema;
    output: typeof ListSourcesResponseSchema;
  },
  /**
   * Creates a new source within the chosen account
   *
   * @generated from rpc account.AdminService.CreateSource
   */
  createSource: {
    methodKind: "unary";
    input: typeof AdminCreateSourceRequestSchema;
    output: typeof CreateSourceResponseSchema;
  },
  /**
   * Get the details of a source within the chosen account
   *
   * @generated from rpc account.AdminService.GetSource
   */
  getSource: {
    methodKind: "unary";
    input: typeof AdminGetSourceRequestSchema;
    output: typeof GetSourceResponseSchema;
  },
  /**
   * Update the details of a source within the chosen account
   *
   * @generated from rpc account.AdminService.UpdateSource
   */
  updateSource: {
    methodKind: "unary";
    input: typeof AdminUpdateSourceRequestSchema;
    output: typeof UpdateSourceResponseSchema;
  },
  /**
   * Deletes a source from a chosen account
   *
   * @generated from rpc account.AdminService.DeleteSource
   */
  deleteSource: {
    methodKind: "unary";
    input: typeof AdminDeleteSourceRequestSchema;
    output: typeof DeleteSourceResponseSchema;
  },
  /**
   * Updates sources to keep them running in the background. This can be used
   * to add explicit action, when the built-in keepalives are not sufficient.
   *
   * @generated from rpc account.AdminService.KeepaliveSources
   */
  keepaliveSources: {
    methodKind: "unary";
    input: typeof AdminKeepaliveSourcesRequestSchema;
    output: typeof KeepaliveSourcesResponseSchema;
  },
  /**
   * Create a new NATS token for a given public NKey. The user requesting must
   * control the associated private key also in order to connect to NATS as
   * the token is not enough on its own
   *
   * @generated from rpc account.AdminService.CreateToken
   */
  createToken: {
    methodKind: "unary";
    input: typeof AdminCreateTokenRequestSchema;
    output: typeof CreateTokenResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_account, 0);

/**
 * RPCs to manage the user's account, sources etc. All requests to this API are
 * scoped to that user's account via the
 * `https://api.overmind.tech/account-name` claim in the supplied token
 *
 * @generated from service account.ManagementService
 */
export const ManagementService: GenService<{
  /**
   * Get the details of the account that this user belongs to
   *
   * @generated from rpc account.ManagementService.GetAccount
   */
  getAccount: {
    methodKind: "unary";
    input: typeof GetAccountRequestSchema;
    output: typeof GetAccountResponseSchema;
  },
  /**
   * Completely deletes the user's account. This includes all of the data in
   * that account, bookmarks, changes etc. It also deletes the current user,
   * and all other users in that account from Auth0
   *
   * @generated from rpc account.ManagementService.DeleteAccount
   */
  deleteAccount: {
    methodKind: "unary";
    input: typeof DeleteAccountRequestSchema;
    output: typeof DeleteAccountResponseSchema;
  },
  /**
   * Lists all sources within the user's account
   *
   * @generated from rpc account.ManagementService.ListSources
   */
  listSources: {
    methodKind: "unary";
    input: typeof ListSourcesRequestSchema;
    output: typeof ListSourcesResponseSchema;
  },
  /**
   * Creates a new source within the user's account
   *
   * @generated from rpc account.ManagementService.CreateSource
   */
  createSource: {
    methodKind: "unary";
    input: typeof CreateSourceRequestSchema;
    output: typeof CreateSourceResponseSchema;
  },
  /**
   * Get the details of a source
   *
   * @generated from rpc account.ManagementService.GetSource
   */
  getSource: {
    methodKind: "unary";
    input: typeof GetSourceRequestSchema;
    output: typeof GetSourceResponseSchema;
  },
  /**
   * Update the details of a source
   *
   * @generated from rpc account.ManagementService.UpdateSource
   */
  updateSource: {
    methodKind: "unary";
    input: typeof UpdateSourceRequestSchema;
    output: typeof UpdateSourceResponseSchema;
  },
  /**
   * Deletes a source from a user's account
   *
   * @generated from rpc account.ManagementService.DeleteSource
   */
  deleteSource: {
    methodKind: "unary";
    input: typeof DeleteSourceRequestSchema;
    output: typeof DeleteSourceResponseSchema;
  },
  /**
   * Sources heartbeat and health
   * List of all recently active sources and their health, includes information from srcman
   * meaning that it can show the status of managed sources that have not started and
   * connected yet
   *
   * @generated from rpc account.ManagementService.ListAllSourcesStatus
   */
  listAllSourcesStatus: {
    methodKind: "unary";
    input: typeof ListAllSourcesStatusRequestSchema;
    output: typeof ListAllSourcesStatusResponseSchema;
  },
  /**
   * Lists all active sources and their health. This should be used to determine
   * what types, scopes etc are available rather than `ListAllSourcesStatus` since
   * this endpoint only include running, available sources
   *
   * @generated from rpc account.ManagementService.ListActiveSourcesStatus
   */
  listActiveSourcesStatus: {
    methodKind: "unary";
    input: typeof ListAllSourcesStatusRequestSchema;
    output: typeof ListAllSourcesStatusResponseSchema;
  },
  /**
   * Heartbeat from a source to keep it registered and healthy
   *
   * @generated from rpc account.ManagementService.SubmitSourceHeartbeat
   */
  submitSourceHeartbeat: {
    methodKind: "unary";
    input: typeof SubmitSourceHeartbeatRequestSchema;
    output: typeof SubmitSourceHeartbeatResponseSchema;
  },
  /**
   * Updates sources to keep them running in the background. This can be used
   * to add explicit action, when the built-in keepalives are not sufficient.
   *
   * @generated from rpc account.ManagementService.KeepaliveSources
   */
  keepaliveSources: {
    methodKind: "unary";
    input: typeof KeepaliveSourcesRequestSchema;
    output: typeof KeepaliveSourcesResponseSchema;
  },
  /**
   * Create a new NATS token for a given public NKey. The user requesting must
   * control the associated private key also in order to connect to NATS as
   * the token is not enough on its own
   *
   * @generated from rpc account.ManagementService.CreateToken
   */
  createToken: {
    methodKind: "unary";
    input: typeof CreateTokenRequestSchema;
    output: typeof CreateTokenResponseSchema;
  },
  /**
   * Ensure that all reverse links are populated. This does internal debouncing
   * so the actual logic does only run when required.
   *
   * @generated from rpc account.ManagementService.RevlinkWarmup
   */
  revlinkWarmup: {
    methodKind: "server_streaming";
    input: typeof RevlinkWarmupRequestSchema;
    output: typeof RevlinkWarmupResponseSchema;
  },
  /**
   * @generated from rpc account.ManagementService.GetTrialEnd
   */
  getTrialEnd: {
    methodKind: "unary";
    input: typeof GetTrialEndRequestSchema;
    output: typeof GetTrialEndResponseSchema;
  },
  /**
   * Lists all the available item types that can be discovered by sources that are running and healthy
   *
   * @generated from rpc account.ManagementService.ListAvailableItemTypes
   */
  listAvailableItemTypes: {
    methodKind: "unary";
    input: typeof ListAvailableItemTypesRequestSchema;
    output: typeof ListAvailableItemTypesResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_account, 1);

