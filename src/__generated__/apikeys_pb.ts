// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file apikeys.proto (package apikeys, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file apikeys.proto.
 */
export const file_apikeys: GenFile = /*@__PURE__*/
  fileDesc("Cg1hcGlrZXlzLnByb3RvEgdhcGlrZXlzImIKBkFQSUtleRIpCghtZXRhZGF0YRgBIAEoCzIXLmFwaWtleXMuQVBJS2V5TWV0YWRhdGESLQoKcHJvcGVydGllcxgCIAEoCzIZLmFwaWtleXMuQVBJS2V5UHJvcGVydGllcyLJAQoOQVBJS2V5TWV0YWRhdGESDAoEdXVpZBgBIAEoDBIrCgdjcmVhdGVkGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIsCghsYXN0VXNlZBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASCwoDa2V5GAQgASgJEg4KBnNjb3BlcxgFIAMoCRIiCgZzdGF0dXMYBiABKA4yEi5hcGlrZXlzLktleVN0YXR1cxINCgVlcnJvchgHIAEoCSIgChBBUElLZXlQcm9wZXJ0aWVzEgwKBG5hbWUYASABKAkiUgoTQ3JlYXRlQVBJS2V5UmVxdWVzdBIMCgRuYW1lGAEgASgJEg4KBnNjb3BlcxgCIAMoCRIdChVmaW5hbEZyb250ZW5kUmVkaXJlY3QYAyABKAkiSgoUQ3JlYXRlQVBJS2V5UmVzcG9uc2USHAoDa2V5GAEgASgLMg8uYXBpa2V5cy5BUElLZXkSFAoMYXV0aG9yaXplVVJMGAIgASgJIkMKFFJlZnJlc2hBUElLZXlSZXF1ZXN0EgwKBHV1aWQYASABKAwSHQoVZmluYWxGcm9udGVuZFJlZGlyZWN0GAIgASgJIkgKFVJlZnJlc2hBUElLZXlSZXNwb25zZRIvCghyZXNwb25zZRgBIAEoCzIdLmFwaWtleXMuQ3JlYXRlQVBJS2V5UmVzcG9uc2UiIAoQR2V0QVBJS2V5UmVxdWVzdBIMCgR1dWlkGAEgASgMIjEKEUdldEFQSUtleVJlc3BvbnNlEhwKA2tleRgBIAEoCzIPLmFwaWtleXMuQVBJS2V5IlIKE1VwZGF0ZUFQSUtleVJlcXVlc3QSDAoEdXVpZBgBIAEoDBItCgpwcm9wZXJ0aWVzGAIgASgLMhkuYXBpa2V5cy5BUElLZXlQcm9wZXJ0aWVzIjQKFFVwZGF0ZUFQSUtleVJlc3BvbnNlEhwKA2tleRgBIAEoCzIPLmFwaWtleXMuQVBJS2V5IhQKEkxpc3RBUElLZXlzUmVxdWVzdCI0ChNMaXN0QVBJS2V5c1Jlc3BvbnNlEh0KBGtleXMYASADKAsyDy5hcGlrZXlzLkFQSUtleSIjChNEZWxldGVBUElLZXlSZXF1ZXN0EgwKBHV1aWQYASABKAwiFgoURGVsZXRlQVBJS2V5UmVzcG9uc2UiLAoaRXhjaGFuZ2VLZXlGb3JUb2tlblJlcXVlc3QSDgoGYXBpS2V5GAEgASgJIjIKG0V4Y2hhbmdlS2V5Rm9yVG9rZW5SZXNwb25zZRITCgthY2Nlc3NUb2tlbhgBIAEoCSqEAQoJS2V5U3RhdHVzEhYKEktFWV9TVEFUVVNfVU5LTk9XThAAEhsKF0tFWV9TVEFUVVNfVU5BVVRIT1JJWkVEEAESFAoQS0VZX1NUQVRVU19SRUFEWRACEhQKEEtFWV9TVEFUVVNfRVJST1IQAxIWChJLRVlfU1RBVFVTX1JFVk9LRUQQBDK2BAoNQXBpS2V5U2VydmljZRJLCgxDcmVhdGVBUElLZXkSHC5hcGlrZXlzLkNyZWF0ZUFQSUtleVJlcXVlc3QaHS5hcGlrZXlzLkNyZWF0ZUFQSUtleVJlc3BvbnNlEk4KDVJlZnJlc2hBUElLZXkSHS5hcGlrZXlzLlJlZnJlc2hBUElLZXlSZXF1ZXN0Gh4uYXBpa2V5cy5SZWZyZXNoQVBJS2V5UmVzcG9uc2USQgoJR2V0QVBJS2V5EhkuYXBpa2V5cy5HZXRBUElLZXlSZXF1ZXN0GhouYXBpa2V5cy5HZXRBUElLZXlSZXNwb25zZRJLCgxVcGRhdGVBUElLZXkSHC5hcGlrZXlzLlVwZGF0ZUFQSUtleVJlcXVlc3QaHS5hcGlrZXlzLlVwZGF0ZUFQSUtleVJlc3BvbnNlEkgKC0xpc3RBUElLZXlzEhsuYXBpa2V5cy5MaXN0QVBJS2V5c1JlcXVlc3QaHC5hcGlrZXlzLkxpc3RBUElLZXlzUmVzcG9uc2USSwoMRGVsZXRlQVBJS2V5EhwuYXBpa2V5cy5EZWxldGVBUElLZXlSZXF1ZXN0Gh0uYXBpa2V5cy5EZWxldGVBUElLZXlSZXNwb25zZRJgChNFeGNoYW5nZUtleUZvclRva2VuEiMuYXBpa2V5cy5FeGNoYW5nZUtleUZvclRva2VuUmVxdWVzdBokLmFwaWtleXMuRXhjaGFuZ2VLZXlGb3JUb2tlblJlc3BvbnNlQiRaImdpdGh1Yi5jb20vb3Zlcm1pbmR0ZWNoL3NkcC1nbztzZHBiBnByb3RvMw", [file_google_protobuf_timestamp]);

/**
 * @generated from message apikeys.APIKey
 */
export type APIKey = Message<"apikeys.APIKey"> & {
  /**
   * @generated from field: apikeys.APIKeyMetadata metadata = 1;
   */
  metadata?: APIKeyMetadata;

  /**
   * @generated from field: apikeys.APIKeyProperties properties = 2;
   */
  properties?: APIKeyProperties;
};

/**
 * Describes the message apikeys.APIKey.
 * Use `create(APIKeySchema)` to create a new message.
 */
export const APIKeySchema: GenMessage<APIKey> = /*@__PURE__*/
  messageDesc(file_apikeys, 0);

/**
 * @generated from message apikeys.APIKeyMetadata
 */
export type APIKeyMetadata = Message<"apikeys.APIKeyMetadata"> & {
  /**
   * The ID of this API key
   *
   * @generated from field: bytes uuid = 1;
   */
  uuid: Uint8Array;

  /**
   * When the API Key was created
   *
   * @generated from field: google.protobuf.Timestamp created = 2;
   */
  created?: Timestamp;

  /**
   * The last time the API key was exchanged for an access token
   *
   * @generated from field: google.protobuf.Timestamp lastUsed = 3;
   */
  lastUsed?: Timestamp;

  /**
   * The actual API key
   *
   * @generated from field: string key = 4;
   */
  key: string;

  /**
   * The list of scopes that this token has access to
   *
   * @generated from field: repeated string scopes = 5;
   */
  scopes: string[];

  /**
   * The status of the key
   *
   * @generated from field: apikeys.KeyStatus status = 6;
   */
  status: KeyStatus;

  /**
   * The error encountered when authorizing the key. This will only be set if
   * the status is ERROR
   *
   * @generated from field: string error = 7;
   */
  error: string;
};

/**
 * Describes the message apikeys.APIKeyMetadata.
 * Use `create(APIKeyMetadataSchema)` to create a new message.
 */
export const APIKeyMetadataSchema: GenMessage<APIKeyMetadata> = /*@__PURE__*/
  messageDesc(file_apikeys, 1);

/**
 * @generated from message apikeys.APIKeyProperties
 */
export type APIKeyProperties = Message<"apikeys.APIKeyProperties"> & {
  /**
   * The name of the API key
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message apikeys.APIKeyProperties.
 * Use `create(APIKeyPropertiesSchema)` to create a new message.
 */
export const APIKeyPropertiesSchema: GenMessage<APIKeyProperties> = /*@__PURE__*/
  messageDesc(file_apikeys, 2);

/**
 * @generated from message apikeys.CreateAPIKeyRequest
 */
export type CreateAPIKeyRequest = Message<"apikeys.CreateAPIKeyRequest"> & {
  /**
   * The name of the key to create
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The scopes that the key should have
   *
   * @generated from field: repeated string scopes = 2;
   */
  scopes: string[];

  /**
   * The URL that the user should be redirected to after the whole process is
   * over. This should be a page in the frontend, probably the one they
   * started from, but could also be a detail page for this particular API key
   *
   * @generated from field: string finalFrontendRedirect = 3;
   */
  finalFrontendRedirect: string;
};

/**
 * Describes the message apikeys.CreateAPIKeyRequest.
 * Use `create(CreateAPIKeyRequestSchema)` to create a new message.
 */
export const CreateAPIKeyRequestSchema: GenMessage<CreateAPIKeyRequest> = /*@__PURE__*/
  messageDesc(file_apikeys, 3);

/**
 * @generated from message apikeys.CreateAPIKeyResponse
 */
export type CreateAPIKeyResponse = Message<"apikeys.CreateAPIKeyResponse"> & {
  /**
   * Details of the newly created API Key
   *
   * @generated from field: apikeys.APIKey key = 1;
   */
  key?: APIKey;

  /**
   * The URL that the user should visit in order to authorize the newly
   * created key. This will allow Auth0 to generate a code that will be passed
   * to the API server via a callback. This code is then exchanged by the API
   * server for an access token and refresh token. The user will be redirected
   * back to the frontend once this process is complete.
   *
   * The authorizeURL will contain a `state` paremeter which is a UUID that
   * can be used to look up the API key in the database once the callback is
   * received
   *
   * @generated from field: string authorizeURL = 2;
   */
  authorizeURL: string;
};

/**
 * Describes the message apikeys.CreateAPIKeyResponse.
 * Use `create(CreateAPIKeyResponseSchema)` to create a new message.
 */
export const CreateAPIKeyResponseSchema: GenMessage<CreateAPIKeyResponse> = /*@__PURE__*/
  messageDesc(file_apikeys, 4);

/**
 * @generated from message apikeys.RefreshAPIKeyRequest
 */
export type RefreshAPIKeyRequest = Message<"apikeys.RefreshAPIKeyRequest"> & {
  /**
   * The UUID of the API key to refresh
   *
   * @generated from field: bytes uuid = 1;
   */
  uuid: Uint8Array;

  /**
   * The URL that the user should be redirected to after the whole process is
   * over. This should be a page in the frontend, probably the one they
   * started from, but could also be a detail page for this particular API key
   *
   * @generated from field: string finalFrontendRedirect = 2;
   */
  finalFrontendRedirect: string;
};

/**
 * Describes the message apikeys.RefreshAPIKeyRequest.
 * Use `create(RefreshAPIKeyRequestSchema)` to create a new message.
 */
export const RefreshAPIKeyRequestSchema: GenMessage<RefreshAPIKeyRequest> = /*@__PURE__*/
  messageDesc(file_apikeys, 5);

/**
 * @generated from message apikeys.RefreshAPIKeyResponse
 */
export type RefreshAPIKeyResponse = Message<"apikeys.RefreshAPIKeyResponse"> & {
  /**
   * Refreshing the API key will return the same response as CreateAPIKey, as
   * it is basically the a new Key, just under the same UUID and reusing the
   * old info.
   *
   * @generated from field: apikeys.CreateAPIKeyResponse response = 1;
   */
  response?: CreateAPIKeyResponse;
};

/**
 * Describes the message apikeys.RefreshAPIKeyResponse.
 * Use `create(RefreshAPIKeyResponseSchema)` to create a new message.
 */
export const RefreshAPIKeyResponseSchema: GenMessage<RefreshAPIKeyResponse> = /*@__PURE__*/
  messageDesc(file_apikeys, 6);

/**
 * @generated from message apikeys.GetAPIKeyRequest
 */
export type GetAPIKeyRequest = Message<"apikeys.GetAPIKeyRequest"> & {
  /**
   * The UUID of the API Key to get
   *
   * @generated from field: bytes uuid = 1;
   */
  uuid: Uint8Array;
};

/**
 * Describes the message apikeys.GetAPIKeyRequest.
 * Use `create(GetAPIKeyRequestSchema)` to create a new message.
 */
export const GetAPIKeyRequestSchema: GenMessage<GetAPIKeyRequest> = /*@__PURE__*/
  messageDesc(file_apikeys, 7);

/**
 * @generated from message apikeys.GetAPIKeyResponse
 */
export type GetAPIKeyResponse = Message<"apikeys.GetAPIKeyResponse"> & {
  /**
   * @generated from field: apikeys.APIKey key = 1;
   */
  key?: APIKey;
};

/**
 * Describes the message apikeys.GetAPIKeyResponse.
 * Use `create(GetAPIKeyResponseSchema)` to create a new message.
 */
export const GetAPIKeyResponseSchema: GenMessage<GetAPIKeyResponse> = /*@__PURE__*/
  messageDesc(file_apikeys, 8);

/**
 * @generated from message apikeys.UpdateAPIKeyRequest
 */
export type UpdateAPIKeyRequest = Message<"apikeys.UpdateAPIKeyRequest"> & {
  /**
   * The UUID of the API key to update
   *
   * @generated from field: bytes uuid = 1;
   */
  uuid: Uint8Array;

  /**
   * New properties to update
   *
   * @generated from field: apikeys.APIKeyProperties properties = 2;
   */
  properties?: APIKeyProperties;
};

/**
 * Describes the message apikeys.UpdateAPIKeyRequest.
 * Use `create(UpdateAPIKeyRequestSchema)` to create a new message.
 */
export const UpdateAPIKeyRequestSchema: GenMessage<UpdateAPIKeyRequest> = /*@__PURE__*/
  messageDesc(file_apikeys, 9);

/**
 * @generated from message apikeys.UpdateAPIKeyResponse
 */
export type UpdateAPIKeyResponse = Message<"apikeys.UpdateAPIKeyResponse"> & {
  /**
   * The updated API key
   *
   * @generated from field: apikeys.APIKey key = 1;
   */
  key?: APIKey;
};

/**
 * Describes the message apikeys.UpdateAPIKeyResponse.
 * Use `create(UpdateAPIKeyResponseSchema)` to create a new message.
 */
export const UpdateAPIKeyResponseSchema: GenMessage<UpdateAPIKeyResponse> = /*@__PURE__*/
  messageDesc(file_apikeys, 10);

/**
 * @generated from message apikeys.ListAPIKeysRequest
 */
export type ListAPIKeysRequest = Message<"apikeys.ListAPIKeysRequest"> & {
};

/**
 * Describes the message apikeys.ListAPIKeysRequest.
 * Use `create(ListAPIKeysRequestSchema)` to create a new message.
 */
export const ListAPIKeysRequestSchema: GenMessage<ListAPIKeysRequest> = /*@__PURE__*/
  messageDesc(file_apikeys, 11);

/**
 * @generated from message apikeys.ListAPIKeysResponse
 */
export type ListAPIKeysResponse = Message<"apikeys.ListAPIKeysResponse"> & {
  /**
   * @generated from field: repeated apikeys.APIKey keys = 1;
   */
  keys: APIKey[];
};

/**
 * Describes the message apikeys.ListAPIKeysResponse.
 * Use `create(ListAPIKeysResponseSchema)` to create a new message.
 */
export const ListAPIKeysResponseSchema: GenMessage<ListAPIKeysResponse> = /*@__PURE__*/
  messageDesc(file_apikeys, 12);

/**
 * @generated from message apikeys.DeleteAPIKeyRequest
 */
export type DeleteAPIKeyRequest = Message<"apikeys.DeleteAPIKeyRequest"> & {
  /**
   * The UUID of the API key to delete
   *
   * @generated from field: bytes uuid = 1;
   */
  uuid: Uint8Array;
};

/**
 * Describes the message apikeys.DeleteAPIKeyRequest.
 * Use `create(DeleteAPIKeyRequestSchema)` to create a new message.
 */
export const DeleteAPIKeyRequestSchema: GenMessage<DeleteAPIKeyRequest> = /*@__PURE__*/
  messageDesc(file_apikeys, 13);

/**
 * @generated from message apikeys.DeleteAPIKeyResponse
 */
export type DeleteAPIKeyResponse = Message<"apikeys.DeleteAPIKeyResponse"> & {
};

/**
 * Describes the message apikeys.DeleteAPIKeyResponse.
 * Use `create(DeleteAPIKeyResponseSchema)` to create a new message.
 */
export const DeleteAPIKeyResponseSchema: GenMessage<DeleteAPIKeyResponse> = /*@__PURE__*/
  messageDesc(file_apikeys, 14);

/**
 * @generated from message apikeys.ExchangeKeyForTokenRequest
 */
export type ExchangeKeyForTokenRequest = Message<"apikeys.ExchangeKeyForTokenRequest"> & {
  /**
   * The API Key that you want to exchange for an Oauth access token
   *
   * @generated from field: string apiKey = 1;
   */
  apiKey: string;
};

/**
 * Describes the message apikeys.ExchangeKeyForTokenRequest.
 * Use `create(ExchangeKeyForTokenRequestSchema)` to create a new message.
 */
export const ExchangeKeyForTokenRequestSchema: GenMessage<ExchangeKeyForTokenRequest> = /*@__PURE__*/
  messageDesc(file_apikeys, 15);

/**
 * @generated from message apikeys.ExchangeKeyForTokenResponse
 */
export type ExchangeKeyForTokenResponse = Message<"apikeys.ExchangeKeyForTokenResponse"> & {
  /**
   * The access token that can now be use to authenticate to Overmind and its
   * APIs
   *
   * @generated from field: string accessToken = 1;
   */
  accessToken: string;
};

/**
 * Describes the message apikeys.ExchangeKeyForTokenResponse.
 * Use `create(ExchangeKeyForTokenResponseSchema)` to create a new message.
 */
export const ExchangeKeyForTokenResponseSchema: GenMessage<ExchangeKeyForTokenResponse> = /*@__PURE__*/
  messageDesc(file_apikeys, 16);

/**
 * @generated from enum apikeys.KeyStatus
 */
export enum KeyStatus {
  /**
   * @generated from enum value: KEY_STATUS_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * This means the key has been created but we have not yet received the
   * callback from Auth0 which allows us to fetch the access token
   *
   * @generated from enum value: KEY_STATUS_UNAUTHORIZED = 1;
   */
  UNAUTHORIZED = 1,

  /**
   * Key is ready for use
   *
   * @generated from enum value: KEY_STATUS_READY = 2;
   */
  READY = 2,

  /**
   * There was an error getting the access token from Auth0
   *
   * @generated from enum value: KEY_STATUS_ERROR = 3;
   */
  ERROR = 3,

  /**
   * The API key has been revoked
   *
   * @generated from enum value: KEY_STATUS_REVOKED = 4;
   */
  REVOKED = 4,
}

/**
 * Describes the enum apikeys.KeyStatus.
 */
export const KeyStatusSchema: GenEnum<KeyStatus> = /*@__PURE__*/
  enumDesc(file_apikeys, 0);

/**
 * The API Key Service is designed to give services like CI, webhooks etc. a
 * simple non-rotating secret that they can use when calling out to Overmind.
 * In order to keep the auth as simple as possible, these API keys don't
 * actually confer any access themselves, they need to be exchanged for an Oauth
 * access token using this API. The server will then return the client a valid
 * token that they can then use for subsequent requests
 *
 *
 * @generated from service apikeys.ApiKeyService
 */
export const ApiKeyService: GenService<{
  /**
   * Creates an API key, pending access token generation from Auth0. The key
   * cannot be used until the user has been redirected to the given URL which
   * allows Auth0 to actually generate an access token
   *
   * @generated from rpc apikeys.ApiKeyService.CreateAPIKey
   */
  createAPIKey: {
    methodKind: "unary";
    input: typeof CreateAPIKeyRequestSchema;
    output: typeof CreateAPIKeyResponseSchema;
  },
  /**
   * Refreshes an API key, returning a new one with the same metadata and
   * properties. The response will be the same as CreateAPIKey, and requires
   * the same redirect handling to authenticate the new key.
   *
   * @generated from rpc apikeys.ApiKeyService.RefreshAPIKey
   */
  refreshAPIKey: {
    methodKind: "unary";
    input: typeof RefreshAPIKeyRequestSchema;
    output: typeof RefreshAPIKeyResponseSchema;
  },
  /**
   * @generated from rpc apikeys.ApiKeyService.GetAPIKey
   */
  getAPIKey: {
    methodKind: "unary";
    input: typeof GetAPIKeyRequestSchema;
    output: typeof GetAPIKeyResponseSchema;
  },
  /**
   * @generated from rpc apikeys.ApiKeyService.UpdateAPIKey
   */
  updateAPIKey: {
    methodKind: "unary";
    input: typeof UpdateAPIKeyRequestSchema;
    output: typeof UpdateAPIKeyResponseSchema;
  },
  /**
   * @generated from rpc apikeys.ApiKeyService.ListAPIKeys
   */
  listAPIKeys: {
    methodKind: "unary";
    input: typeof ListAPIKeysRequestSchema;
    output: typeof ListAPIKeysResponseSchema;
  },
  /**
   * @generated from rpc apikeys.ApiKeyService.DeleteAPIKey
   */
  deleteAPIKey: {
    methodKind: "unary";
    input: typeof DeleteAPIKeyRequestSchema;
    output: typeof DeleteAPIKeyResponseSchema;
  },
  /**
   * Exchanges an Overmind API key for an Oauth access token. That token can
   * then be used to access all other Overmind APIs
   *
   * @generated from rpc apikeys.ApiKeyService.ExchangeKeyForToken
   */
  exchangeKeyForToken: {
    methodKind: "unary";
    input: typeof ExchangeKeyForTokenRequestSchema;
    output: typeof ExchangeKeyForTokenResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_apikeys, 0);

