// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=.ts"
// @generated from file config.proto (package config, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { CreateAPIKeyResponse } from "./apikeys_pb.ts";

/**
 * The config that is used when calculating the blast radius for a change, this
 * does not affect manually requested blast radii vie the "Explore" view or the
 * API
 *
 * @generated from message config.BlastRadiusConfig
 */
export class BlastRadiusConfig extends Message<BlastRadiusConfig> {
  /**
   * The maximum number of items that can be returned in a single blast radius
   * request. Once a request has hit this limit, all currently running
   * requests will be cancelled and the blast radius returned as-is
   *
   * @generated from field: int32 maxItems = 1;
   */
  maxItems = 0;

  /**
   * How deeply to link when calculating the blast radius for a change
   *
   * @generated from field: int32 linkDepth = 2;
   */
  linkDepth = 0;

  constructor(data?: PartialMessage<BlastRadiusConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.BlastRadiusConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "maxItems", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "linkDepth", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlastRadiusConfig {
    return new BlastRadiusConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlastRadiusConfig {
    return new BlastRadiusConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlastRadiusConfig {
    return new BlastRadiusConfig().fromJsonString(jsonString, options);
  }

  static equals(a: BlastRadiusConfig | PlainMessage<BlastRadiusConfig> | undefined, b: BlastRadiusConfig | PlainMessage<BlastRadiusConfig> | undefined): boolean {
    return proto3.util.equals(BlastRadiusConfig, a, b);
  }
}

/**
 * This account config is stored in the `kv.Store` protobuf key-value store in
 * the api-server database. This means that as long as we don't have any
 * *breaking* changes to the protobuf, we shouldn't need to do a migration. If
 * however we do need to change this message in a breaking way, we will need to
 * do some kind of a migration (depending on the change)
 *
 * @generated from message config.AccountConfig
 */
export class AccountConfig extends Message<AccountConfig> {
  /**
   * The preset that we should use when calculating the blast radius for a
   * change. If this is set to "CUSTOM" then the `blastRadius` config should be
   * set
   *
   * @generated from field: config.AccountConfig.BlastRadiusPreset blastRadiusPreset = 2;
   */
  blastRadiusPreset = AccountConfig_BlastRadiusPreset.CUSTOM;

  /**
   * The blast radius config for this account, this is only required if the
   * preset is "CUSTOM"
   *
   * @generated from field: optional config.BlastRadiusConfig blastRadius = 1;
   */
  blastRadius?: BlastRadiusConfig;

  /**
   * If this is set to true, changes that weren't able to be mapped to real
   * infrastructure won't be considered for risk calculations. This usually
   * reduces the number low-quality and low-severity risks, and focuses more
   * on risks that we have additional context for. If you find that Overmind's
   * risks are "too obvious" then this might be a good setting to enable.
   *
   * @generated from field: bool skipUnmappedChangesForRisks = 3;
   */
  skipUnmappedChangesForRisks = false;

  constructor(data?: PartialMessage<AccountConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.AccountConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "blastRadiusPreset", kind: "enum", T: proto3.getEnumType(AccountConfig_BlastRadiusPreset) },
    { no: 1, name: "blastRadius", kind: "message", T: BlastRadiusConfig, opt: true },
    { no: 3, name: "skipUnmappedChangesForRisks", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountConfig {
    return new AccountConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountConfig {
    return new AccountConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountConfig {
    return new AccountConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AccountConfig | PlainMessage<AccountConfig> | undefined, b: AccountConfig | PlainMessage<AccountConfig> | undefined): boolean {
    return proto3.util.equals(AccountConfig, a, b);
  }
}

/**
 * @generated from enum config.AccountConfig.BlastRadiusPreset
 */
export enum AccountConfig_BlastRadiusPreset {
  /**
   * Customise advanced limits.
   *
   * @generated from enum value: CUSTOM = 0;
   */
  CUSTOM = 0,

  /**
   * Runs a shallow scan for dependencies. Reduces time takes to calculate
   * blast radius, but might mean some dependencies are missed
   *
   * @generated from enum value: QUICK = 1;
   */
  QUICK = 1,

  /**
   * An optimised balance between time taken and discovery.
   *
   * @generated from enum value: DETAILED = 2;
   */
  DETAILED = 2,

  /**
   * Discovers all possible dependencies, might take a long time and
   * discover items that are less likely to be relevant to a change.
   *
   * @generated from enum value: FULL = 3;
   */
  FULL = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AccountConfig_BlastRadiusPreset)
proto3.util.setEnumType(AccountConfig_BlastRadiusPreset, "config.AccountConfig.BlastRadiusPreset", [
  { no: 0, name: "CUSTOM" },
  { no: 1, name: "QUICK" },
  { no: 2, name: "DETAILED" },
  { no: 3, name: "FULL" },
]);

/**
 * @generated from message config.GetAccountConfigRequest
 */
export class GetAccountConfigRequest extends Message<GetAccountConfigRequest> {
  constructor(data?: PartialMessage<GetAccountConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.GetAccountConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountConfigRequest {
    return new GetAccountConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountConfigRequest {
    return new GetAccountConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountConfigRequest {
    return new GetAccountConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountConfigRequest | PlainMessage<GetAccountConfigRequest> | undefined, b: GetAccountConfigRequest | PlainMessage<GetAccountConfigRequest> | undefined): boolean {
    return proto3.util.equals(GetAccountConfigRequest, a, b);
  }
}

/**
 * @generated from message config.GetAccountConfigResponse
 */
export class GetAccountConfigResponse extends Message<GetAccountConfigResponse> {
  /**
   * @generated from field: config.AccountConfig config = 1;
   */
  config?: AccountConfig;

  constructor(data?: PartialMessage<GetAccountConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.GetAccountConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: AccountConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountConfigResponse {
    return new GetAccountConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountConfigResponse {
    return new GetAccountConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountConfigResponse {
    return new GetAccountConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountConfigResponse | PlainMessage<GetAccountConfigResponse> | undefined, b: GetAccountConfigResponse | PlainMessage<GetAccountConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetAccountConfigResponse, a, b);
  }
}

/**
 * Updates the account config for the user's account.
 *
 * @generated from message config.UpdateAccountConfigRequest
 */
export class UpdateAccountConfigRequest extends Message<UpdateAccountConfigRequest> {
  /**
   * @generated from field: config.AccountConfig config = 1;
   */
  config?: AccountConfig;

  constructor(data?: PartialMessage<UpdateAccountConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.UpdateAccountConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: AccountConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateAccountConfigRequest {
    return new UpdateAccountConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateAccountConfigRequest {
    return new UpdateAccountConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateAccountConfigRequest {
    return new UpdateAccountConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateAccountConfigRequest | PlainMessage<UpdateAccountConfigRequest> | undefined, b: UpdateAccountConfigRequest | PlainMessage<UpdateAccountConfigRequest> | undefined): boolean {
    return proto3.util.equals(UpdateAccountConfigRequest, a, b);
  }
}

/**
 * @generated from message config.UpdateAccountConfigResponse
 */
export class UpdateAccountConfigResponse extends Message<UpdateAccountConfigResponse> {
  /**
   * @generated from field: config.AccountConfig config = 1;
   */
  config?: AccountConfig;

  constructor(data?: PartialMessage<UpdateAccountConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.UpdateAccountConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: AccountConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateAccountConfigResponse {
    return new UpdateAccountConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateAccountConfigResponse {
    return new UpdateAccountConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateAccountConfigResponse {
    return new UpdateAccountConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateAccountConfigResponse | PlainMessage<UpdateAccountConfigResponse> | undefined, b: UpdateAccountConfigResponse | PlainMessage<UpdateAccountConfigResponse> | undefined): boolean {
    return proto3.util.equals(UpdateAccountConfigResponse, a, b);
  }
}

/**
 * @generated from message config.CreateHcpConfigRequest
 */
export class CreateHcpConfigRequest extends Message<CreateHcpConfigRequest> {
  /**
   * The URL that the user should be redirected to after the whole process is
   * over. This should be a page in the frontend, probably the HCP Terraform
   * Integration page.
   *
   * @generated from field: string finalFrontendRedirect = 1;
   */
  finalFrontendRedirect = "";

  constructor(data?: PartialMessage<CreateHcpConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.CreateHcpConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "finalFrontendRedirect", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateHcpConfigRequest {
    return new CreateHcpConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateHcpConfigRequest {
    return new CreateHcpConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateHcpConfigRequest {
    return new CreateHcpConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateHcpConfigRequest | PlainMessage<CreateHcpConfigRequest> | undefined, b: CreateHcpConfigRequest | PlainMessage<CreateHcpConfigRequest> | undefined): boolean {
    return proto3.util.equals(CreateHcpConfigRequest, a, b);
  }
}

/**
 * @generated from message config.CreateHcpConfigResponse
 */
export class CreateHcpConfigResponse extends Message<CreateHcpConfigResponse> {
  /**
   * @generated from field: config.HcpConfig config = 1;
   */
  config?: HcpConfig;

  /**
   * @generated from field: apikeys.CreateAPIKeyResponse apiKey = 2;
   */
  apiKey?: CreateAPIKeyResponse;

  constructor(data?: PartialMessage<CreateHcpConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.CreateHcpConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: HcpConfig },
    { no: 2, name: "apiKey", kind: "message", T: CreateAPIKeyResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateHcpConfigResponse {
    return new CreateHcpConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateHcpConfigResponse {
    return new CreateHcpConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateHcpConfigResponse {
    return new CreateHcpConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateHcpConfigResponse | PlainMessage<CreateHcpConfigResponse> | undefined, b: CreateHcpConfigResponse | PlainMessage<CreateHcpConfigResponse> | undefined): boolean {
    return proto3.util.equals(CreateHcpConfigResponse, a, b);
  }
}

/**
 * @generated from message config.HcpConfig
 */
export class HcpConfig extends Message<HcpConfig> {
  /**
   * the Endpoint URL for the HCP Run Task configuration
   *
   * @generated from field: string endpoint = 1;
   */
  endpoint = "";

  /**
   * the HMAC secret for the HCP Run Task configuration
   *
   * @generated from field: string secret = 2;
   */
  secret = "";

  constructor(data?: PartialMessage<HcpConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.HcpConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "secret", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HcpConfig {
    return new HcpConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HcpConfig {
    return new HcpConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HcpConfig {
    return new HcpConfig().fromJsonString(jsonString, options);
  }

  static equals(a: HcpConfig | PlainMessage<HcpConfig> | undefined, b: HcpConfig | PlainMessage<HcpConfig> | undefined): boolean {
    return proto3.util.equals(HcpConfig, a, b);
  }
}

/**
 * @generated from message config.GetHcpConfigRequest
 */
export class GetHcpConfigRequest extends Message<GetHcpConfigRequest> {
  constructor(data?: PartialMessage<GetHcpConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.GetHcpConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetHcpConfigRequest {
    return new GetHcpConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetHcpConfigRequest {
    return new GetHcpConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetHcpConfigRequest {
    return new GetHcpConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetHcpConfigRequest | PlainMessage<GetHcpConfigRequest> | undefined, b: GetHcpConfigRequest | PlainMessage<GetHcpConfigRequest> | undefined): boolean {
    return proto3.util.equals(GetHcpConfigRequest, a, b);
  }
}

/**
 * @generated from message config.GetHcpConfigResponse
 */
export class GetHcpConfigResponse extends Message<GetHcpConfigResponse> {
  /**
   * @generated from field: config.HcpConfig config = 1;
   */
  config?: HcpConfig;

  constructor(data?: PartialMessage<GetHcpConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.GetHcpConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: HcpConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetHcpConfigResponse {
    return new GetHcpConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetHcpConfigResponse {
    return new GetHcpConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetHcpConfigResponse {
    return new GetHcpConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetHcpConfigResponse | PlainMessage<GetHcpConfigResponse> | undefined, b: GetHcpConfigResponse | PlainMessage<GetHcpConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetHcpConfigResponse, a, b);
  }
}

/**
 * @generated from message config.DeleteHcpConfigRequest
 */
export class DeleteHcpConfigRequest extends Message<DeleteHcpConfigRequest> {
  constructor(data?: PartialMessage<DeleteHcpConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.DeleteHcpConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteHcpConfigRequest {
    return new DeleteHcpConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteHcpConfigRequest {
    return new DeleteHcpConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteHcpConfigRequest {
    return new DeleteHcpConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteHcpConfigRequest | PlainMessage<DeleteHcpConfigRequest> | undefined, b: DeleteHcpConfigRequest | PlainMessage<DeleteHcpConfigRequest> | undefined): boolean {
    return proto3.util.equals(DeleteHcpConfigRequest, a, b);
  }
}

/**
 * @generated from message config.DeleteHcpConfigResponse
 */
export class DeleteHcpConfigResponse extends Message<DeleteHcpConfigResponse> {
  constructor(data?: PartialMessage<DeleteHcpConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.DeleteHcpConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteHcpConfigResponse {
    return new DeleteHcpConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteHcpConfigResponse {
    return new DeleteHcpConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteHcpConfigResponse {
    return new DeleteHcpConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteHcpConfigResponse | PlainMessage<DeleteHcpConfigResponse> | undefined, b: DeleteHcpConfigResponse | PlainMessage<DeleteHcpConfigResponse> | undefined): boolean {
    return proto3.util.equals(DeleteHcpConfigResponse, a, b);
  }
}

