// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file items.proto (syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Response } from "./responses_pb";
import { file_responses } from "./responses_pb";
import type { JsonObject, Message } from "@bufbuild/protobuf";

/**
 * Describes the file items.proto.
 */
export const file_items: GenFile = /*@__PURE__*/
  fileDesc("CgtpdGVtcy5wcm90byIrChBCbGFzdFByb3BhZ2F0aW9uEgoKAmluGAEgASgIEgsKA291dBgCIAEoCCJVCg9MaW5rZWRJdGVtUXVlcnkSFQoFcXVlcnkYASABKAsyBi5RdWVyeRIrChBibGFzdFByb3BhZ2F0aW9uGAIgASgLMhEuQmxhc3RQcm9wYWdhdGlvbiJTCgpMaW5rZWRJdGVtEhgKBGl0ZW0YASABKAsyCi5SZWZlcmVuY2USKwoQYmxhc3RQcm9wYWdhdGlvbhgCIAEoCzIRLkJsYXN0UHJvcGFnYXRpb24iwgIKBEl0ZW0SDAoEdHlwZRgBIAEoCRIXCg91bmlxdWVBdHRyaWJ1dGUYAiABKAkSIwoKYXR0cmlidXRlcxgDIAEoCzIPLkl0ZW1BdHRyaWJ1dGVzEhsKCG1ldGFkYXRhGAQgASgLMgkuTWV0YWRhdGESDQoFc2NvcGUYBSABKAkSKwoRbGlua2VkSXRlbVF1ZXJpZXMYECADKAsyEC5MaW5rZWRJdGVtUXVlcnkSIAoLbGlua2VkSXRlbXMYESADKAsyCy5MaW5rZWRJdGVtEhwKBmhlYWx0aBgSIAEoDjIHLkhlYWx0aEgAiAEBEh0KBHRhZ3MYEyADKAsyDy5JdGVtLlRhZ3NFbnRyeRorCglUYWdzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUIJCgdfaGVhbHRoIj0KDkl0ZW1BdHRyaWJ1dGVzEisKCmF0dHJTdHJ1Y3QYASABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0Iu8BCghNZXRhZGF0YRISCgpzb3VyY2VOYW1lGAIgASgJEhsKC3NvdXJjZVF1ZXJ5GAMgASgLMgYuUXVlcnkSLQoJdGltZXN0YW1wGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI1Cg5zb3VyY2VEdXJhdGlvbhgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkICGAESPAoVc291cmNlRHVyYXRpb25QZXJJdGVtGAYgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQgIYARIOCgZoaWRkZW4YByABKAgiHQoFSXRlbXMSFAoFaXRlbXMYASADKAsyBS5JdGVtIqwCCgVRdWVyeRIMCgR0eXBlGAEgASgJEhwKBm1ldGhvZBgCIAEoDjIMLlF1ZXJ5TWV0aG9kEg0KBXF1ZXJ5GAMgASgJEjUKEnJlY3Vyc2lvbkJlaGF2aW91chgEIAEoCzIZLlF1ZXJ5LlJlY3Vyc2lvbkJlaGF2aW91chINCgVzY29wZRgFIAEoCRITCgtpZ25vcmVDYWNoZRgGIAEoCBIMCgRVVUlEGAcgASgMEiwKCGRlYWRsaW5lGAkgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBpLChJSZWN1cnNpb25CZWhhdmlvdXISEQoJbGlua0RlcHRoGAEgASgNEiIKGmZvbGxvd09ubHlCbGFzdFByb3BhZ2F0aW9uGAIgASgISgQICBAJIncKDVF1ZXJ5UmVzcG9uc2USGAoHbmV3SXRlbRgCIAEoCzIFLkl0ZW1IABIdCghyZXNwb25zZRgDIAEoCzIJLlJlc3BvbnNlSAASHAoFZXJyb3IYBCABKAsyCy5RdWVyeUVycm9ySABCDwoNcmVzcG9uc2VfdHlwZSKYAQoLUXVlcnlTdGF0dXMSDAoEVVVJRBgBIAEoDBIjCgZzdGF0dXMYAiABKA4yEy5RdWVyeVN0YXR1cy5TdGF0dXMiVgoGU3RhdHVzEg8KC1VOU1BFQ0lGSUVEEAASCwoHU1RBUlRFRBABEg0KCUNBTkNFTExFRBADEgsKB0VSUk9SRUQQBBIMCghGSU5JU0hFRBAFIgQIAhACIuUBCgpRdWVyeUVycm9yEgwKBFVVSUQYASABKAwSKAoJZXJyb3JUeXBlGAIgASgOMhUuUXVlcnlFcnJvci5FcnJvclR5cGUSEwoLZXJyb3JTdHJpbmcYAyABKAkSDQoFc2NvcGUYBCABKAkSEgoKc291cmNlTmFtZRgFIAEoCRIQCghpdGVtVHlwZRgGIAEoCRIVCg1yZXNwb25kZXJOYW1lGAcgASgJIj4KCUVycm9yVHlwZRIJCgVPVEhFUhAAEgwKCE5PVEZPVU5EEAESCwoHTk9TQ09QRRACEgsKB1RJTUVPVVQQAyIbCgtDYW5jZWxRdWVyeRIMCgRVVUlEGAEgASgMIhkKCVVuZG9RdWVyeRIMCgRVVUlEGAEgASgMInEKBkV4cGFuZBIYCgRpdGVtGAEgASgLMgouUmVmZXJlbmNlEhEKCWxpbmtEZXB0aBgCIAEoDRIMCgRVVUlEGAMgASgMEiwKCGRlYWRsaW5lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCIaCgpVbmRvRXhwYW5kEgwKBFVVSUQYASABKAwihAEKCVJlZmVyZW5jZRIMCgR0eXBlGAEgASgJEhwKFHVuaXF1ZUF0dHJpYnV0ZVZhbHVlGAIgASgJEg0KBXNjb3BlGAMgASgJEg8KB2lzUXVlcnkYBCABKAgSDQoFcXVlcnkYBSABKAkSHAoGbWV0aG9kGAYgASgOMgwuUXVlcnlNZXRob2QiZQoERWRnZRIYCgRmcm9tGAEgASgLMgouUmVmZXJlbmNlEhYKAnRvGAIgASgLMgouUmVmZXJlbmNlEisKEGJsYXN0UHJvcGFnYXRpb24YAyABKAsyES5CbGFzdFByb3BhZ2F0aW9uKmUKBkhlYWx0aBISCg5IRUFMVEhfVU5LTk9XThAAEg0KCUhFQUxUSF9PSxABEhIKDkhFQUxUSF9XQVJOSU5HEAISEAoMSEVBTFRIX0VSUk9SEAMSEgoOSEVBTFRIX1BFTkRJTkcQBCosCgtRdWVyeU1ldGhvZBIHCgNHRVQQABIICgRMSVNUEAESCgoGU0VBUkNIEAJCJFoiZ2l0aHViLmNvbS9vdmVybWluZHRlY2gvc2RwLWdvO3NkcGIGcHJvdG8z", [file_google_protobuf_duration, file_google_protobuf_struct, file_google_protobuf_timestamp, file_responses]);

/**
 * This message stores additional information on Edges (and edge-like constructs) to determine how configuration changes can impact
 * the linked items.
 *
 *  Blast Propagation options:
 * |-------|-------|----------------------
 * |   in  |  out  | result
 * |-------|-------|----------------------
 * | false | false | no change in any item can affect the other
 * | false | true  | a change to this item can affect its linked items
 * |       |       | example: a change to an EC2 instance can affect its DNS name (in the sense that other items depending on that DNS name will see the impact)
 * | true  | false | a change to linked items can affect this item
 * |       |       | example: changing the KMS key used by a DynamoDB table can impact the table, but no change to the table can impact the key
 * | true  | true  | changes on both sides of the link can affect the other
 * |       |       | example: changes to both EC2 Instances and their volumes can affect the other side of the relation.
 *
 * @generated from message BlastPropagation
 */
export type BlastPropagation = Message<"BlastPropagation"> & {
  /**
   * is true if changes on linked items can affect this item
   *
   * @generated from field: bool in = 1;
   */
  in: boolean;

  /**
   * is true if changes on this item can affect linked items
   *
   * @generated from field: bool out = 2;
   */
  out: boolean;
};

/**
 * Describes the message BlastPropagation.
 * Use `create(BlastPropagationSchema)` to create a new message.
 */
export const BlastPropagationSchema: GenMessage<BlastPropagation> = /*@__PURE__*/
  messageDesc(file_items, 0);

/**
 * An annotated query to indicate potential linked items.
 *
 * @generated from message LinkedItemQuery
 */
export type LinkedItemQuery = Message<"LinkedItemQuery"> & {
  /**
   * the query that would find linked items
   *
   * @generated from field: Query query = 1;
   */
  query?: Query;

  /**
   * how configuration changes (i.e. the "blast") propagates over this link
   *
   * @generated from field: BlastPropagation blastPropagation = 2;
   */
  blastPropagation?: BlastPropagation;
};

/**
 * Describes the message LinkedItemQuery.
 * Use `create(LinkedItemQuerySchema)` to create a new message.
 */
export const LinkedItemQuerySchema: GenMessage<LinkedItemQuery> = /*@__PURE__*/
  messageDesc(file_items, 1);

/**
 * An annotated reference to list linked items.
 *
 * @generated from message LinkedItem
 */
export type LinkedItem = Message<"LinkedItem"> & {
  /**
   * the linked item
   *
   * @generated from field: Reference item = 1;
   */
  item?: Reference;

  /**
   * how configuration changes (i.e. the "blast") propagates over this link
   *
   * @generated from field: BlastPropagation blastPropagation = 2;
   */
  blastPropagation?: BlastPropagation;
};

/**
 * Describes the message LinkedItem.
 * Use `create(LinkedItemSchema)` to create a new message.
 */
export const LinkedItemSchema: GenMessage<LinkedItem> = /*@__PURE__*/
  messageDesc(file_items, 2);

/**
 * This is the same as Item within the package with a couple of exceptions, no
 * real reason why this whole thing couldn't be modelled in protobuf though if
 * required. Just need to decide what if anything should remain private
 *
 * @generated from message Item
 */
export type Item = Message<"Item"> & {
  /**
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: string uniqueAttribute = 2;
   */
  uniqueAttribute: string;

  /**
   * @generated from field: ItemAttributes attributes = 3;
   */
  attributes?: ItemAttributes;

  /**
   * @generated from field: Metadata metadata = 4;
   */
  metadata?: Metadata;

  /**
   * The scope within which the item is unique. Item uniqueness is determined
   * by the combination of type and uniqueAttribute value. However it is
   * possible for the same item to exist in many scopes. There is not formal
   * definition for what a scope should be other than the fact that it should
   * be somewhat descriptive and should ensure item uniqueness
   *
   * @generated from field: string scope = 5;
   */
  scope: string;

  /**
   * Not all items will have relatedItems we are are using a two byte
   * integer to save one byte integers for more common things
   *
   * @generated from field: repeated LinkedItemQuery linkedItemQueries = 16;
   */
  linkedItemQueries: LinkedItemQuery[];

  /**
   * Linked items
   *
   * @generated from field: repeated LinkedItem linkedItems = 17;
   */
  linkedItems: LinkedItem[];

  /**
   * (optional) Represents the health of the item. Only items that have a
   * clearly relevant health attribute should return a value for health
   *
   * @generated from field: optional Health health = 18;
   */
  health?: Health;

  /**
   * Arbitrary key-value pairs that can be used to store additional information.
   * These tags are retrieved from the source and map to the target's definition
   * of a tag (e.g. AWS tags, Kubernetes labels, etc.)
   *
   * @generated from field: map<string, string> tags = 19;
   */
  tags: { [key: string]: string };
};

/**
 * Describes the message Item.
 * Use `create(ItemSchema)` to create a new message.
 */
export const ItemSchema: GenMessage<Item> = /*@__PURE__*/
  messageDesc(file_items, 3);

/**
 * ItemAttributes represents the known attributes for an item. These are likely
 * to be common to a given type, but even this is not guaranteed. All items must
 * have at least one attribute however as it needs something to uniquely
 * identify it
 *
 * @generated from message ItemAttributes
 */
export type ItemAttributes = Message<"ItemAttributes"> & {
  /**
   * @generated from field: google.protobuf.Struct attrStruct = 1;
   */
  attrStruct?: JsonObject;
};

/**
 * Describes the message ItemAttributes.
 * Use `create(ItemAttributesSchema)` to create a new message.
 */
export const ItemAttributesSchema: GenMessage<ItemAttributes> = /*@__PURE__*/
  messageDesc(file_items, 4);

/**
 * Metadata about the item. Where it came from, how long it took, etc.
 *
 * @generated from message Metadata
 */
export type Metadata = Message<"Metadata"> & {
  /**
   * This is the name of the source that was used to find the item.
   *
   * @generated from field: string sourceName = 2;
   */
  sourceName: string;

  /**
   * The query that caused this item to be found. This is for gateway-internal use and will not be exposed to the frontend.
   *
   * @generated from field: Query sourceQuery = 3;
   */
  sourceQuery?: Query;

  /**
   * The time that the item was found
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 4;
   */
  timestamp?: Timestamp;

  /**
   * How long the source took to execute in total when processing the Query.
   *
   * (deprecated) This is no longer sent as streaming responses make this metric
   * impossible to calculate on a per-item basis
   *
   * @generated from field: google.protobuf.Duration sourceDuration = 5 [deprecated = true];
   * @deprecated
   */
  sourceDuration?: Duration;

  /**
   * How long the source took to execute per item when processing the
   * Query
   *
   * (deprecated) This is no longer sent
   *
   * @generated from field: google.protobuf.Duration sourceDurationPerItem = 6 [deprecated = true];
   * @deprecated
   */
  sourceDurationPerItem?: Duration;

  /**
   * Whether the item should be hidden/ignored by user-facing things such as
   * GUIs and databases.
   *
   * Some types of items are only relevant in calculating higher-layer
   * abstractions and are therefore always hidden. A good example of this would
   * be the output of a command. This could be used by a remote source to gather
   * information, but we don't actually want to show the user all the commands
   * that were run, just the final item returned by the source
   *
   * @generated from field: bool hidden = 7;
   */
  hidden: boolean;
};

/**
 * Describes the message Metadata.
 * Use `create(MetadataSchema)` to create a new message.
 */
export const MetadataSchema: GenMessage<Metadata> = /*@__PURE__*/
  messageDesc(file_items, 5);

/**
 * This is a list of items, like a List() would return
 *
 * @generated from message Items
 */
export type Items = Message<"Items"> & {
  /**
   * @generated from field: repeated Item items = 1;
   */
  items: Item[];
};

/**
 * Describes the message Items.
 * Use `create(ItemsSchema)` to create a new message.
 */
export const ItemsSchema: GenMessage<Items> = /*@__PURE__*/
  messageDesc(file_items, 6);

/**
 * Query represents a query for an item or a list of items.
 *
 * @generated from message Query
 */
export type Query = Message<"Query"> & {
  /**
   * The type of item to search for. "*" means all types
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Which method to use when looking for it
   *
   * @generated from field: QueryMethod method = 2;
   */
  method: QueryMethod;

  /**
   * What query should be passed to that method
   *
   * @generated from field: string query = 3;
   */
  query: string;

  /**
   * Defines how this query should behave when finding new items
   *
   * @generated from field: Query.RecursionBehaviour recursionBehaviour = 4;
   */
  recursionBehaviour?: Query_RecursionBehaviour;

  /**
   * The scope for which we are requesting. To query all scopes use the the
   * wildcard '*'
   *
   * @generated from field: string scope = 5;
   */
  scope: string;

  /**
   * Whether to ignore the cache and execute the query regardless.
   *
   * By default sources will implement some level of caching, this is
   * particularly important for linked items as a single query with a large link
   * depth may result in the same item being queried many times as links are
   * resolved and more and more items link to each other. However if required
   * this caching can be turned off using this parameter
   *
   * @generated from field: bool ignoreCache = 6;
   */
  ignoreCache: boolean;

  /**
   * A UUID to uniquely identify the query. This should be stored by the
   * requester as it will be needed later if the requester wants to cancel a
   * query. It should be stored as 128 bytes, as opposed to the textual
   * representation
   *
   * @generated from field: bytes UUID = 7;
   */
  UUID: Uint8Array;

  /**
   * The deadline for this query. When the deadline elapses, results become
   * irrelevant for the sender and any processing can stop. The deadline gets
   * propagated to all related queries (e.g. for linked items) and processes.
   * Note: there is currently a migration going on from timeouts to durations,
   * so depending on which service is hit, either one is evaluated.
   *
   * @generated from field: google.protobuf.Timestamp deadline = 9;
   */
  deadline?: Timestamp;
};

/**
 * Describes the message Query.
 * Use `create(QuerySchema)` to create a new message.
 */
export const QuerySchema: GenMessage<Query> = /*@__PURE__*/
  messageDesc(file_items, 7);

/**
 * Defines how this query should behave when finding new items
 *
 * @generated from message Query.RecursionBehaviour
 */
export type Query_RecursionBehaviour = Message<"Query.RecursionBehaviour"> & {
  /**
   * How deeply to link items. A value of 0 will mean that items are not linked.
   * To resolve linked items "infinitely" simply set this to a high number, with
   * the highest being 4,294,967,295. While this isn't truly *infinite*, chances
   * are that it is effectively the same, think six degrees of separation etc.
   *
   * @generated from field: uint32 linkDepth = 1;
   */
  linkDepth: number;

  /**
   * set to true to only follow links that propagate configuration change impact
   *
   * @generated from field: bool followOnlyBlastPropagation = 2;
   */
  followOnlyBlastPropagation: boolean;
};

/**
 * Describes the message Query.RecursionBehaviour.
 * Use `create(Query_RecursionBehaviourSchema)` to create a new message.
 */
export const Query_RecursionBehaviourSchema: GenMessage<Query_RecursionBehaviour> = /*@__PURE__*/
  messageDesc(file_items, 7, 0);

/**
 * @generated from message QueryResponse
 */
export type QueryResponse = Message<"QueryResponse"> & {
  /**
   * @generated from oneof QueryResponse.response_type
   */
  responseType: {
    /**
     * A new item that has been discovered
     *
     * @generated from field: Item newItem = 2;
     */
    value: Item;
    case: "newItem";
  } | {
    /**
     * Status update
     *
     * @generated from field: Response response = 3;
     */
    value: Response;
    case: "response";
  } | {
    /**
     * An error has been encountered
     *
     * @generated from field: QueryError error = 4;
     */
    value: QueryError;
    case: "error";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message QueryResponse.
 * Use `create(QueryResponseSchema)` to create a new message.
 */
export const QueryResponseSchema: GenMessage<QueryResponse> = /*@__PURE__*/
  messageDesc(file_items, 8);

/**
 * QueryStatus informs the client of status updates of all queries running in this session.
 *
 * @generated from message QueryStatus
 */
export type QueryStatus = Message<"QueryStatus"> & {
  /**
   * UUID of the query
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;

  /**
   * @generated from field: QueryStatus.Status status = 2;
   */
  status: QueryStatus_Status;
};

/**
 * Describes the message QueryStatus.
 * Use `create(QueryStatusSchema)` to create a new message.
 */
export const QueryStatusSchema: GenMessage<QueryStatus> = /*@__PURE__*/
  messageDesc(file_items, 9);

/**
 * The error type. Any types in here will be gracefully handled unless the
 * type os "OTHER"
 *
 * @generated from enum QueryStatus.Status
 */
export enum QueryStatus_Status {
  /**
   * the status has not been specified
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * the query has been started
   *
   * @generated from enum value: STARTED = 1;
   */
  STARTED = 1,

  /**
   * the query has been cancelled.
   * This is a final state.
   *
   * @generated from enum value: CANCELLED = 3;
   */
  CANCELLED = 3,

  /**
   * the query has finished with an error status. expect a separate QueryError describing that.
   * This is a final state.
   * TODO: fold the error details into this message
   *
   * @generated from enum value: ERRORED = 4;
   */
  ERRORED = 4,

  /**
   * The query has finished and all results have been sent over the wire
   * This is a final state.
   *
   * @generated from enum value: FINISHED = 5;
   */
  FINISHED = 5,
}

/**
 * Describes the enum QueryStatus.Status.
 */
export const QueryStatus_StatusSchema: GenEnum<QueryStatus_Status> = /*@__PURE__*/
  enumDesc(file_items, 9, 0);

/**
 * QueryError is sent back when an item query fails
 *
 * @generated from message QueryError
 */
export type QueryError = Message<"QueryError"> & {
  /**
   * UUID of the item query that this response is in relation to (in binary
   * format)
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;

  /**
   * @generated from field: QueryError.ErrorType errorType = 2;
   */
  errorType: QueryError_ErrorType;

  /**
   * The string contents of the error
   *
   * @generated from field: string errorString = 3;
   */
  errorString: string;

  /**
   * The scope from which the error was raised
   *
   * @generated from field: string scope = 4;
   */
  scope: string;

  /**
   * The name of the source which raised the error (if relevant)
   *
   * @generated from field: string sourceName = 5;
   */
  sourceName: string;

  /**
   * The type of item that we were looking for at the time of the error
   *
   * @generated from field: string itemType = 6;
   */
  itemType: string;

  /**
   * The name of the responder that this error was raised from
   *
   * @generated from field: string responderName = 7;
   */
  responderName: string;
};

/**
 * Describes the message QueryError.
 * Use `create(QueryErrorSchema)` to create a new message.
 */
export const QueryErrorSchema: GenMessage<QueryError> = /*@__PURE__*/
  messageDesc(file_items, 10);

/**
 * The error type. Any types in here will be gracefully handled unless the
 * type os "OTHER"
 *
 * @generated from enum QueryError.ErrorType
 */
export enum QueryError_ErrorType {
  /**
   * This should be used of all other failure modes, such as timeouts,
   * unexpected failures when querying state, permissions errors etc. Errors
   * that return this type should not be cached as the error may be transient.
   *
   * @generated from enum value: OTHER = 0;
   */
  OTHER = 0,

  /**
   * NOTFOUND means that the item was not found. This is only returned as the
   * result of a GET query since all other queries would return an empty
   * list instead
   *
   * @generated from enum value: NOTFOUND = 1;
   */
  NOTFOUND = 1,

  /**
   * NOSCOPE means that the item was not found because we don't have
   * access to the requested scope. This should not be interpreted as "The
   * item doesn't exist" (as with a NOTFOUND error) but rather as "We can't
   * tell you whether or not the item exists"
   *
   * @generated from enum value: NOSCOPE = 2;
   */
  NOSCOPE = 2,

  /**
   * TIMEOUT means that the source times out when trying to query the item.
   * The timeout is provided in the original query
   *
   * @generated from enum value: TIMEOUT = 3;
   */
  TIMEOUT = 3,
}

/**
 * Describes the enum QueryError.ErrorType.
 */
export const QueryError_ErrorTypeSchema: GenEnum<QueryError_ErrorType> = /*@__PURE__*/
  enumDesc(file_items, 10, 0);

/**
 * The message signals that the Query with the corresponding UUID should
 * be cancelled. Work should stop immediately, and a final response should be
 * sent with a state of CANCELLED to acknowledge that the query has ended due
 * to a cancellation
 *
 * @generated from message CancelQuery
 */
export type CancelQuery = Message<"CancelQuery"> & {
  /**
   * UUID of the Query to cancel
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;
};

/**
 * Describes the message CancelQuery.
 * Use `create(CancelQuerySchema)` to create a new message.
 */
export const CancelQuerySchema: GenMessage<CancelQuery> = /*@__PURE__*/
  messageDesc(file_items, 11);

/**
 * This message is sent to the gateway to instruct it to "undo" a query. This
 * means that the query will be removed from the session, along with all items
 * and edges that were a result of that query. If these items have already
 * been sent to the client, the gateway will send `deleteItem` messages instructing
 * the client to delete them
 *
 * @generated from message UndoQuery
 */
export type UndoQuery = Message<"UndoQuery"> & {
  /**
   * UUID of the Query to cancel
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;
};

/**
 * Describes the message UndoQuery.
 * Use `create(UndoQuerySchema)` to create a new message.
 */
export const UndoQuerySchema: GenMessage<UndoQuery> = /*@__PURE__*/
  messageDesc(file_items, 12);

/**
 * This requests that the gateway "expands" an item. This involves executing all
 * linked item queries within the session and sending the results to the
 * client. It is recommended that this be used rather than simply sending each
 * linked item request. Using this request type allows the Gateway to save the
 * session more intelligently so that it can be bookmarked and used later.
 * "Expanding" an item will mean an item always acts the same, even if its
 * linked item queries have changed
 *
 * @generated from message Expand
 */
export type Expand = Message<"Expand"> & {
  /**
   * The item that should be expanded
   *
   * @generated from field: Reference item = 1;
   */
  item?: Reference;

  /**
   * How many levels of expansion should be run
   *
   * @generated from field: uint32 linkDepth = 2;
   */
  linkDepth: number;

  /**
   * A UUID to uniquely identify the request. This should be stored by the
   * requester as it will be needed later if the requester wants to cancel a
   * request. It should be stored as 128 bytes, as opposed to the textual
   * representation
   *
   * @generated from field: bytes UUID = 3;
   */
  UUID: Uint8Array;

  /**
   * The time at which the gateway should stop processing the queries spawned by this request
   *
   * @generated from field: google.protobuf.Timestamp deadline = 4;
   */
  deadline?: Timestamp;
};

/**
 * Describes the message Expand.
 * Use `create(ExpandSchema)` to create a new message.
 */
export const ExpandSchema: GenMessage<Expand> = /*@__PURE__*/
  messageDesc(file_items, 13);

/**
 * This message is sent to the gateway to instruct it to "undo" an Expand. This
 * means that the expansion will be removed from the session, along with all items
 * and edges that were a result of that request. If these items have already
 * been sent to the client, the gateway will send `deleteItem` messages instructing
 * the client to delete them
 *
 * @generated from message UndoExpand
 */
export type UndoExpand = Message<"UndoExpand"> & {
  /**
   * UUID of the Expand to cancel
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID: Uint8Array;
};

/**
 * Describes the message UndoExpand.
 * Use `create(UndoExpandSchema)` to create a new message.
 */
export const UndoExpandSchema: GenMessage<UndoExpand> = /*@__PURE__*/
  messageDesc(file_items, 14);

/**
 * Reference to an item
 *
 * The uniqueness of an item is determined by the combination of:
 *
 *   * Type
 *   * UniqueAttributeValue
 *   * Scope
 *
 *
 * @generated from message Reference
 */
export type Reference = Message<"Reference"> & {
  /**
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: string uniqueAttributeValue = 2;
   */
  uniqueAttributeValue: string;

  /**
   * @generated from field: string scope = 3;
   */
  scope: string;

  /**
   * @generated from field: bool isQuery = 4;
   */
  isQuery: boolean;

  /**
   * @generated from field: string query = 5;
   */
  query: string;

  /**
   * @generated from field: QueryMethod method = 6;
   */
  method: QueryMethod;
};

/**
 * Describes the message Reference.
 * Use `create(ReferenceSchema)` to create a new message.
 */
export const ReferenceSchema: GenMessage<Reference> = /*@__PURE__*/
  messageDesc(file_items, 15);

/**
 * Edge Represents a link between two items, it is not used in regular SDP
 * queries as it's up to the client to infer the edges from the LinkedItems
 * field, however request managed by the gateway will explicitly send edges to
 * reduce the processing burden on the client side
 *
 * @generated from message Edge
 */
export type Edge = Message<"Edge"> & {
  /**
   * @generated from field: Reference from = 1;
   */
  from?: Reference;

  /**
   * @generated from field: Reference to = 2;
   */
  to?: Reference;

  /**
   * @generated from field: BlastPropagation blastPropagation = 3;
   */
  blastPropagation?: BlastPropagation;
};

/**
 * Describes the message Edge.
 * Use `create(EdgeSchema)` to create a new message.
 */
export const EdgeSchema: GenMessage<Edge> = /*@__PURE__*/
  messageDesc(file_items, 16);

/**
 * Represents the health of something, the meaning of each state may depend on
 * the context in which it is used but should be reasonably obvious
 *
 * @generated from enum Health
 */
export enum Health {
  /**
   * The health could not be determined
   *
   * @generated from enum value: HEALTH_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Functioning normally
   *
   * @generated from enum value: HEALTH_OK = 1;
   */
  OK = 1,

  /**
   * Functioning, but degraded
   *
   * @generated from enum value: HEALTH_WARNING = 2;
   */
  WARNING = 2,

  /**
   * Not functioning
   *
   * @generated from enum value: HEALTH_ERROR = 3;
   */
  ERROR = 3,

  /**
   * Health state is transitioning, such as when something is first provisioned
   *
   * @generated from enum value: HEALTH_PENDING = 4;
   */
  PENDING = 4,
}

/**
 * Describes the enum Health.
 */
export const HealthSchema: GenEnum<Health> = /*@__PURE__*/
  enumDesc(file_items, 0);

/**
 * QueryMethod represents the available query methods. The details of these
 * methods are:
 *
 * GET: This takes a single unique query and should only return a single item.
 *      If an item matching the parameter passed doesn't exist the server should
 *      fail
 *
 * LIST: This takes no query (or ignores it) and should return all items that it
 *       can find
 *
 * SEARCH: This takes a non-unique query which is designed to be used as a
 *         search term. It should return some number of items (or zero) which
 *         match the query
 *
 * @generated from enum QueryMethod
 */
export enum QueryMethod {
  /**
   * @generated from enum value: GET = 0;
   */
  GET = 0,

  /**
   * @generated from enum value: LIST = 1;
   */
  LIST = 1,

  /**
   * @generated from enum value: SEARCH = 2;
   */
  SEARCH = 2,
}

/**
 * Describes the enum QueryMethod.
 */
export const QueryMethodSchema: GenEnum<QueryMethod> = /*@__PURE__*/
  enumDesc(file_items, 1);

