// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=.ts"
// @generated from file items.proto (syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Struct, Timestamp } from "@bufbuild/protobuf";
import { Response } from "./responses_pb.ts";

/**
 * Represents the health of something, the meaning of each state may depend on
 * the context in which it is used but should be reasonably obvious
 *
 * @generated from enum Health
 */
export enum Health {
  /**
   * The health could not be determined
   *
   * @generated from enum value: HEALTH_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Functioning normally
   *
   * @generated from enum value: HEALTH_OK = 1;
   */
  OK = 1,

  /**
   * Functioning, but degraded
   *
   * @generated from enum value: HEALTH_WARNING = 2;
   */
  WARNING = 2,

  /**
   * Not functioning
   *
   * @generated from enum value: HEALTH_ERROR = 3;
   */
  ERROR = 3,

  /**
   * Health state is transitioning, such as when something is first provisioned
   *
   * @generated from enum value: HEALTH_PENDING = 4;
   */
  PENDING = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(Health)
proto3.util.setEnumType(Health, "Health", [
  { no: 0, name: "HEALTH_UNKNOWN" },
  { no: 1, name: "HEALTH_OK" },
  { no: 2, name: "HEALTH_WARNING" },
  { no: 3, name: "HEALTH_ERROR" },
  { no: 4, name: "HEALTH_PENDING" },
]);

/**
 * QueryMethod represents the available query methods. The details of these
 * methods are:
 *
 * GET: This takes a single unique query and should only return a single item.
 *      If an item matching the parameter passed doesn't exist the server should
 *      fail
 *
 * LIST: This takes no query (or ignores it) and should return all items that it
 *       can find
 *
 * SEARCH: This takes a non-unique query which is designed to be used as a
 *         search term. It should return some number of items (or zero) which
 *         match the query
 *
 * @generated from enum QueryMethod
 */
export enum QueryMethod {
  /**
   * @generated from enum value: GET = 0;
   */
  GET = 0,

  /**
   * @generated from enum value: LIST = 1;
   */
  LIST = 1,

  /**
   * @generated from enum value: SEARCH = 2;
   */
  SEARCH = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(QueryMethod)
proto3.util.setEnumType(QueryMethod, "QueryMethod", [
  { no: 0, name: "GET" },
  { no: 1, name: "LIST" },
  { no: 2, name: "SEARCH" },
]);

/**
 * This message stores additional information on Edges (and edge-like constructs) to determine how configuration changes can impact
 * the linked items.
 *
 *  Blast Propagation options:
 * |-------|-------|----------------------
 * |   in  |  out  | result
 * |-------|-------|----------------------
 * | false | false | no change in any item can affect the other
 * | false | true  | a change to this item can affect its linked items
 * |       |       | example: a change to an EC2 instance can affect its DNS name (in the sense that other items depending on that DNS name will see the impact)
 * | true  | false | a change to linked items can affect this item
 * |       |       | example: changing the KMS key used by a DynamoDB table can impact the table, but no change to the table can impact the key
 * | true  | true  | changes on both sides of the link can affect the other
 * |       |       | example: changes to both EC2 Instances and their volumes can affect the other side of the relation.
 *
 * @generated from message BlastPropagation
 */
export class BlastPropagation extends Message<BlastPropagation> {
  /**
   * is true if changes on linked items can affect this item
   *
   * @generated from field: bool in = 1;
   */
  in = false;

  /**
   * is true if changes on this item can affect linked items
   *
   * @generated from field: bool out = 2;
   */
  out = false;

  constructor(data?: PartialMessage<BlastPropagation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "BlastPropagation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "in", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "out", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlastPropagation {
    return new BlastPropagation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlastPropagation {
    return new BlastPropagation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlastPropagation {
    return new BlastPropagation().fromJsonString(jsonString, options);
  }

  static equals(a: BlastPropagation | PlainMessage<BlastPropagation> | undefined, b: BlastPropagation | PlainMessage<BlastPropagation> | undefined): boolean {
    return proto3.util.equals(BlastPropagation, a, b);
  }
}

/**
 * An annotated query to indicate potential linked items.
 *
 * @generated from message LinkedItemQuery
 */
export class LinkedItemQuery extends Message<LinkedItemQuery> {
  /**
   * the query that would find linked items
   *
   * @generated from field: Query query = 1;
   */
  query?: Query;

  /**
   * how configuration changes (i.e. the "blast") propagates over this link
   *
   * @generated from field: BlastPropagation blastPropagation = 2;
   */
  blastPropagation?: BlastPropagation;

  constructor(data?: PartialMessage<LinkedItemQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "LinkedItemQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "message", T: Query },
    { no: 2, name: "blastPropagation", kind: "message", T: BlastPropagation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinkedItemQuery {
    return new LinkedItemQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinkedItemQuery {
    return new LinkedItemQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinkedItemQuery {
    return new LinkedItemQuery().fromJsonString(jsonString, options);
  }

  static equals(a: LinkedItemQuery | PlainMessage<LinkedItemQuery> | undefined, b: LinkedItemQuery | PlainMessage<LinkedItemQuery> | undefined): boolean {
    return proto3.util.equals(LinkedItemQuery, a, b);
  }
}

/**
 * An annotated reference to list linked items.
 *
 * @generated from message LinkedItem
 */
export class LinkedItem extends Message<LinkedItem> {
  /**
   * the linked item
   *
   * @generated from field: Reference item = 1;
   */
  item?: Reference;

  /**
   * how configuration changes (i.e. the "blast") propagates over this link
   *
   * @generated from field: BlastPropagation blastPropagation = 2;
   */
  blastPropagation?: BlastPropagation;

  constructor(data?: PartialMessage<LinkedItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "LinkedItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "item", kind: "message", T: Reference },
    { no: 2, name: "blastPropagation", kind: "message", T: BlastPropagation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinkedItem {
    return new LinkedItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinkedItem {
    return new LinkedItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinkedItem {
    return new LinkedItem().fromJsonString(jsonString, options);
  }

  static equals(a: LinkedItem | PlainMessage<LinkedItem> | undefined, b: LinkedItem | PlainMessage<LinkedItem> | undefined): boolean {
    return proto3.util.equals(LinkedItem, a, b);
  }
}

/**
 * This is the same as Item within the package with a couple of exceptions, no
 * real reason why this whole thing couldn't be modelled in protobuf though if
 * required. Just need to decide what if anything should remain private
 *
 * @generated from message Item
 */
export class Item extends Message<Item> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: string uniqueAttribute = 2;
   */
  uniqueAttribute = "";

  /**
   * @generated from field: ItemAttributes attributes = 3;
   */
  attributes?: ItemAttributes;

  /**
   * @generated from field: Metadata metadata = 4;
   */
  metadata?: Metadata;

  /**
   * The scope within which the item is unique. Item uniqueness is determined
   * by the combination of type and uniqueAttribute value. However it is
   * possible for the same item to exist in many scopes. There is not formal
   * definition for what a scope should be other than the fact that it should
   * be somewhat descriptive and should ensure item uniqueness
   *
   * @generated from field: string scope = 5;
   */
  scope = "";

  /**
   * Not all items will have relatedItems we are are using a two byte
   * integer to save one byte integers for more common things
   *
   * @generated from field: repeated LinkedItemQuery linkedItemQueries = 16;
   */
  linkedItemQueries: LinkedItemQuery[] = [];

  /**
   * Linked items
   *
   * @generated from field: repeated LinkedItem linkedItems = 17;
   */
  linkedItems: LinkedItem[] = [];

  /**
   * (optional) Represents the health of the item. Only items that have a
   * clearly relevant health attribute should return a value for health
   *
   * @generated from field: optional Health health = 18;
   */
  health?: Health;

  /**
   * Arbitrary key-value pairs that can be used to store additional information.
   * These tags are retrieved from the source and map to the target's definition
   * of a tag (e.g. AWS tags, Kubernetes labels, etc.)
   *
   * @generated from field: map<string, string> tags = 19;
   */
  tags: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Item>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Item";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "uniqueAttribute", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "attributes", kind: "message", T: ItemAttributes },
    { no: 4, name: "metadata", kind: "message", T: Metadata },
    { no: 5, name: "scope", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "linkedItemQueries", kind: "message", T: LinkedItemQuery, repeated: true },
    { no: 17, name: "linkedItems", kind: "message", T: LinkedItem, repeated: true },
    { no: 18, name: "health", kind: "enum", T: proto3.getEnumType(Health), opt: true },
    { no: 19, name: "tags", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Item {
    return new Item().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Item {
    return new Item().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Item {
    return new Item().fromJsonString(jsonString, options);
  }

  static equals(a: Item | PlainMessage<Item> | undefined, b: Item | PlainMessage<Item> | undefined): boolean {
    return proto3.util.equals(Item, a, b);
  }
}

/**
 * ItemAttributes represents the known attributes for an item. These are likely
 * to be common to a given type, but even this is not guaranteed. All items must
 * have at least one attribute however as it needs something to uniquely
 * identify it
 *
 * @generated from message ItemAttributes
 */
export class ItemAttributes extends Message<ItemAttributes> {
  /**
   * @generated from field: google.protobuf.Struct attrStruct = 1;
   */
  attrStruct?: Struct;

  constructor(data?: PartialMessage<ItemAttributes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ItemAttributes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "attrStruct", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ItemAttributes {
    return new ItemAttributes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ItemAttributes {
    return new ItemAttributes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ItemAttributes {
    return new ItemAttributes().fromJsonString(jsonString, options);
  }

  static equals(a: ItemAttributes | PlainMessage<ItemAttributes> | undefined, b: ItemAttributes | PlainMessage<ItemAttributes> | undefined): boolean {
    return proto3.util.equals(ItemAttributes, a, b);
  }
}

/**
 * Metadata about the item. Where it came from, how long it took, etc.
 *
 * @generated from message Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * This is the name of the source that was used to find the item.
   *
   * @generated from field: string sourceName = 2;
   */
  sourceName = "";

  /**
   * The query that caused this item to be found. This is for gateway-internal use and will not be exposed to the frontend.
   *
   * @generated from field: Query sourceQuery = 3;
   */
  sourceQuery?: Query;

  /**
   * The time that the item was found
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 4;
   */
  timestamp?: Timestamp;

  /**
   * How long the source took to execute in total when processing the Query.
   *
   * (deprecated) This is no longer sent as streaming responses make this metric
   * impossible to calculate on a per-item basis
   *
   * @generated from field: google.protobuf.Duration sourceDuration = 5 [deprecated = true];
   * @deprecated
   */
  sourceDuration?: Duration;

  /**
   * How long the source took to execute per item when processing the
   * Query
   *
   * (deprecated) This is no longer sent
   *
   * @generated from field: google.protobuf.Duration sourceDurationPerItem = 6 [deprecated = true];
   * @deprecated
   */
  sourceDurationPerItem?: Duration;

  /**
   * Whether the item should be hidden/ignored by user-facing things such as
   * GUIs and databases.
   *
   * Some types of items are only relevant in calculating higher-layer
   * abstractions and are therefore always hidden. A good example of this would
   * be the output of a command. This could be used by a remote source to gather
   * information, but we don't actually want to show the user all the commands
   * that were run, just the final item returned by the source
   *
   * @generated from field: bool hidden = 7;
   */
  hidden = false;

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "sourceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sourceQuery", kind: "message", T: Query },
    { no: 4, name: "timestamp", kind: "message", T: Timestamp },
    { no: 5, name: "sourceDuration", kind: "message", T: Duration },
    { no: 6, name: "sourceDurationPerItem", kind: "message", T: Duration },
    { no: 7, name: "hidden", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * This is a list of items, like a List() would return
 *
 * @generated from message Items
 */
export class Items extends Message<Items> {
  /**
   * @generated from field: repeated Item items = 1;
   */
  items: Item[] = [];

  constructor(data?: PartialMessage<Items>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Items";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: Item, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Items {
    return new Items().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Items {
    return new Items().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Items {
    return new Items().fromJsonString(jsonString, options);
  }

  static equals(a: Items | PlainMessage<Items> | undefined, b: Items | PlainMessage<Items> | undefined): boolean {
    return proto3.util.equals(Items, a, b);
  }
}

/**
 * Query represents a query for an item or a list of items.
 *
 * @generated from message Query
 */
export class Query extends Message<Query> {
  /**
   * The type of item to search for. "*" means all types
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * Which method to use when looking for it
   *
   * @generated from field: QueryMethod method = 2;
   */
  method = QueryMethod.GET;

  /**
   * What query should be passed to that method
   *
   * @generated from field: string query = 3;
   */
  query = "";

  /**
   * Defines how this query should behave when finding new items
   *
   * @generated from field: Query.RecursionBehaviour recursionBehaviour = 4;
   */
  recursionBehaviour?: Query_RecursionBehaviour;

  /**
   * The scope for which we are requesting. To query all scopes use the the
   * wildcard '*'
   *
   * @generated from field: string scope = 5;
   */
  scope = "";

  /**
   * Whether to ignore the cache and execute the query regardless.
   *
   * By default sources will implement some level of caching, this is
   * particularly important for linked items as a single query with a large link
   * depth may result in the same item being queried many times as links are
   * resolved and more and more items link to each other. However if required
   * this caching can be turned off using this parameter
   *
   * @generated from field: bool ignoreCache = 6;
   */
  ignoreCache = false;

  /**
   * A UUID to uniquely identify the query. This should be stored by the
   * requester as it will be needed later if the requester wants to cancel a
   * query. It should be stored as 128 bytes, as opposed to the textual
   * representation
   *
   * @generated from field: bytes UUID = 7;
   */
  UUID = new Uint8Array(0);

  /**
   * The deadline for this query. When the deadline elapses, results become
   * irrelevant for the sender and any processing can stop. The deadline gets
   * propagated to all related queries (e.g. for linked items) and processes.
   * Note: there is currently a migration going on from timeouts to durations,
   * so depending on which service is hit, either one is evaluated.
   *
   * @generated from field: google.protobuf.Timestamp deadline = 9;
   */
  deadline?: Timestamp;

  constructor(data?: PartialMessage<Query>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Query";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "method", kind: "enum", T: proto3.getEnumType(QueryMethod) },
    { no: 3, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "recursionBehaviour", kind: "message", T: Query_RecursionBehaviour },
    { no: 5, name: "scope", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "ignoreCache", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "deadline", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query {
    return new Query().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJsonString(jsonString, options);
  }

  static equals(a: Query | PlainMessage<Query> | undefined, b: Query | PlainMessage<Query> | undefined): boolean {
    return proto3.util.equals(Query, a, b);
  }
}

/**
 * Defines how this query should behave when finding new items
 *
 * @generated from message Query.RecursionBehaviour
 */
export class Query_RecursionBehaviour extends Message<Query_RecursionBehaviour> {
  /**
   * How deeply to link items. A value of 0 will mean that items are not linked.
   * To resolve linked items "infinitely" simply set this to a high number, with
   * the highest being 4,294,967,295. While this isn't truly *infinite*, chances
   * are that it is effectively the same, think six degrees of separation etc.
   *
   * @generated from field: uint32 linkDepth = 1;
   */
  linkDepth = 0;

  /**
   * set to true to only follow links that propagate configuration change impact
   *
   * @generated from field: bool followOnlyBlastPropagation = 2;
   */
  followOnlyBlastPropagation = false;

  constructor(data?: PartialMessage<Query_RecursionBehaviour>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Query.RecursionBehaviour";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "linkDepth", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "followOnlyBlastPropagation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_RecursionBehaviour {
    return new Query_RecursionBehaviour().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_RecursionBehaviour {
    return new Query_RecursionBehaviour().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_RecursionBehaviour {
    return new Query_RecursionBehaviour().fromJsonString(jsonString, options);
  }

  static equals(a: Query_RecursionBehaviour | PlainMessage<Query_RecursionBehaviour> | undefined, b: Query_RecursionBehaviour | PlainMessage<Query_RecursionBehaviour> | undefined): boolean {
    return proto3.util.equals(Query_RecursionBehaviour, a, b);
  }
}

/**
 * @generated from message QueryResponse
 */
export class QueryResponse extends Message<QueryResponse> {
  /**
   * @generated from oneof QueryResponse.response_type
   */
  responseType: {
    /**
     * A new item that has been discovered
     *
     * @generated from field: Item newItem = 2;
     */
    value: Item;
    case: "newItem";
  } | {
    /**
     * Status update
     *
     * @generated from field: Response response = 3;
     */
    value: Response;
    case: "response";
  } | {
    /**
     * An error has been encountered
     *
     * @generated from field: QueryError error = 4;
     */
    value: QueryError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<QueryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "QueryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "newItem", kind: "message", T: Item, oneof: "response_type" },
    { no: 3, name: "response", kind: "message", T: Response, oneof: "response_type" },
    { no: 4, name: "error", kind: "message", T: QueryError, oneof: "response_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResponse {
    return new QueryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResponse {
    return new QueryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResponse {
    return new QueryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryResponse | PlainMessage<QueryResponse> | undefined, b: QueryResponse | PlainMessage<QueryResponse> | undefined): boolean {
    return proto3.util.equals(QueryResponse, a, b);
  }
}

/**
 * QueryStatus informs the client of status updates of all queries running in this session.
 *
 * @generated from message QueryStatus
 */
export class QueryStatus extends Message<QueryStatus> {
  /**
   * UUID of the query
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  /**
   * @generated from field: QueryStatus.Status status = 2;
   */
  status = QueryStatus_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<QueryStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "QueryStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(QueryStatus_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryStatus {
    return new QueryStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryStatus {
    return new QueryStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryStatus {
    return new QueryStatus().fromJsonString(jsonString, options);
  }

  static equals(a: QueryStatus | PlainMessage<QueryStatus> | undefined, b: QueryStatus | PlainMessage<QueryStatus> | undefined): boolean {
    return proto3.util.equals(QueryStatus, a, b);
  }
}

/**
 * The error type. Any types in here will be gracefully handled unless the
 * type os "OTHER"
 *
 * @generated from enum QueryStatus.Status
 */
export enum QueryStatus_Status {
  /**
   * the status has not been specified
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * the query has been started
   *
   * @generated from enum value: STARTED = 1;
   */
  STARTED = 1,

  /**
   * the query has been cancelled.
   * This is a final state.
   *
   * @generated from enum value: CANCELLED = 3;
   */
  CANCELLED = 3,

  /**
   * the query has finished with an error status. expect a separate QueryError describing that.
   * This is a final state.
   * TODO: fold the error details into this message
   *
   * @generated from enum value: ERRORED = 4;
   */
  ERRORED = 4,

  /**
   * The query has finished and all results have been sent over the wire
   * This is a final state.
   *
   * @generated from enum value: FINISHED = 5;
   */
  FINISHED = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(QueryStatus_Status)
proto3.util.setEnumType(QueryStatus_Status, "QueryStatus.Status", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "STARTED" },
  { no: 3, name: "CANCELLED" },
  { no: 4, name: "ERRORED" },
  { no: 5, name: "FINISHED" },
]);

/**
 * QueryError is sent back when an item query fails
 *
 * @generated from message QueryError
 */
export class QueryError extends Message<QueryError> {
  /**
   * UUID of the item query that this response is in relation to (in binary
   * format)
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  /**
   * @generated from field: QueryError.ErrorType errorType = 2;
   */
  errorType = QueryError_ErrorType.OTHER;

  /**
   * The string contents of the error
   *
   * @generated from field: string errorString = 3;
   */
  errorString = "";

  /**
   * The scope from which the error was raised
   *
   * @generated from field: string scope = 4;
   */
  scope = "";

  /**
   * The name of the source which raised the error (if relevant)
   *
   * @generated from field: string sourceName = 5;
   */
  sourceName = "";

  /**
   * The type of item that we were looking for at the time of the error
   *
   * @generated from field: string itemType = 6;
   */
  itemType = "";

  /**
   * The name of the responder that this error was raised from
   *
   * @generated from field: string responderName = 7;
   */
  responderName = "";

  constructor(data?: PartialMessage<QueryError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "QueryError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "errorType", kind: "enum", T: proto3.getEnumType(QueryError_ErrorType) },
    { no: 3, name: "errorString", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "scope", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "sourceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "itemType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "responderName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryError {
    return new QueryError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryError {
    return new QueryError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryError {
    return new QueryError().fromJsonString(jsonString, options);
  }

  static equals(a: QueryError | PlainMessage<QueryError> | undefined, b: QueryError | PlainMessage<QueryError> | undefined): boolean {
    return proto3.util.equals(QueryError, a, b);
  }
}

/**
 * The error type. Any types in here will be gracefully handled unless the
 * type os "OTHER"
 *
 * @generated from enum QueryError.ErrorType
 */
export enum QueryError_ErrorType {
  /**
   * This should be used of all other failure modes, such as timeouts,
   * unexpected failures when querying state, permissions errors etc. Errors
   * that return this type should not be cached as the error may be transient.
   *
   * @generated from enum value: OTHER = 0;
   */
  OTHER = 0,

  /**
   * NOTFOUND means that the item was not found. This is only returned as the
   * result of a GET query since all other queries would return an empty
   * list instead
   *
   * @generated from enum value: NOTFOUND = 1;
   */
  NOTFOUND = 1,

  /**
   * NOSCOPE means that the item was not found because we don't have
   * access to the requested scope. This should not be interpreted as "The
   * item doesn't exist" (as with a NOTFOUND error) but rather as "We can't
   * tell you whether or not the item exists"
   *
   * @generated from enum value: NOSCOPE = 2;
   */
  NOSCOPE = 2,

  /**
   * TIMEOUT means that the source times out when trying to query the item.
   * The timeout is provided in the original query
   *
   * @generated from enum value: TIMEOUT = 3;
   */
  TIMEOUT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(QueryError_ErrorType)
proto3.util.setEnumType(QueryError_ErrorType, "QueryError.ErrorType", [
  { no: 0, name: "OTHER" },
  { no: 1, name: "NOTFOUND" },
  { no: 2, name: "NOSCOPE" },
  { no: 3, name: "TIMEOUT" },
]);

/**
 * The message signals that the Query with the corresponding UUID should
 * be cancelled. Work should stop immediately, and a final response should be
 * sent with a state of CANCELLED to acknowledge that the query has ended due
 * to a cancellation
 *
 * @generated from message CancelQuery
 */
export class CancelQuery extends Message<CancelQuery> {
  /**
   * UUID of the Query to cancel
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  constructor(data?: PartialMessage<CancelQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "CancelQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelQuery {
    return new CancelQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelQuery {
    return new CancelQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CancelQuery {
    return new CancelQuery().fromJsonString(jsonString, options);
  }

  static equals(a: CancelQuery | PlainMessage<CancelQuery> | undefined, b: CancelQuery | PlainMessage<CancelQuery> | undefined): boolean {
    return proto3.util.equals(CancelQuery, a, b);
  }
}

/**
 * This message is sent to the gateway to instruct it to "undo" a query. This
 * means that the query will be removed from the session, along with all items
 * and edges that were a result of that query. If these items have already
 * been sent to the client, the gateway will send `deleteItem` messages instructing
 * the client to delete them
 *
 * @generated from message UndoQuery
 */
export class UndoQuery extends Message<UndoQuery> {
  /**
   * UUID of the Query to cancel
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  constructor(data?: PartialMessage<UndoQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "UndoQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UndoQuery {
    return new UndoQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UndoQuery {
    return new UndoQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UndoQuery {
    return new UndoQuery().fromJsonString(jsonString, options);
  }

  static equals(a: UndoQuery | PlainMessage<UndoQuery> | undefined, b: UndoQuery | PlainMessage<UndoQuery> | undefined): boolean {
    return proto3.util.equals(UndoQuery, a, b);
  }
}

/**
 * This requests that the gateway "expands" an item. This involves executing all
 * linked item queries within the session and sending the results to the
 * client. It is recommended that this be used rather than simply sending each
 * linked item request. Using this request type allows the Gateway to save the
 * session more intelligently so that it can be bookmarked and used later.
 * "Expanding" an item will mean an item always acts the same, even if its
 * linked item queries have changed
 *
 * @generated from message Expand
 */
export class Expand extends Message<Expand> {
  /**
   * The item that should be expanded
   *
   * @generated from field: Reference item = 1;
   */
  item?: Reference;

  /**
   * How many levels of expansion should be run
   *
   * @generated from field: uint32 linkDepth = 2;
   */
  linkDepth = 0;

  /**
   * A UUID to uniquely identify the request. This should be stored by the
   * requester as it will be needed later if the requester wants to cancel a
   * request. It should be stored as 128 bytes, as opposed to the textual
   * representation
   *
   * @generated from field: bytes UUID = 3;
   */
  UUID = new Uint8Array(0);

  /**
   * The time at which the gateway should stop processing the queries spawned by this request
   *
   * @generated from field: google.protobuf.Timestamp deadline = 4;
   */
  deadline?: Timestamp;

  constructor(data?: PartialMessage<Expand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Expand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "item", kind: "message", T: Reference },
    { no: 2, name: "linkDepth", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "deadline", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Expand {
    return new Expand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Expand {
    return new Expand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Expand {
    return new Expand().fromJsonString(jsonString, options);
  }

  static equals(a: Expand | PlainMessage<Expand> | undefined, b: Expand | PlainMessage<Expand> | undefined): boolean {
    return proto3.util.equals(Expand, a, b);
  }
}

/**
 * This message is sent to the gateway to instruct it to "undo" an Expand. This
 * means that the expansion will be removed from the session, along with all items
 * and edges that were a result of that request. If these items have already
 * been sent to the client, the gateway will send `deleteItem` messages instructing
 * the client to delete them
 *
 * @generated from message UndoExpand
 */
export class UndoExpand extends Message<UndoExpand> {
  /**
   * UUID of the Expand to cancel
   *
   * @generated from field: bytes UUID = 1;
   */
  UUID = new Uint8Array(0);

  constructor(data?: PartialMessage<UndoExpand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "UndoExpand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UUID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UndoExpand {
    return new UndoExpand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UndoExpand {
    return new UndoExpand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UndoExpand {
    return new UndoExpand().fromJsonString(jsonString, options);
  }

  static equals(a: UndoExpand | PlainMessage<UndoExpand> | undefined, b: UndoExpand | PlainMessage<UndoExpand> | undefined): boolean {
    return proto3.util.equals(UndoExpand, a, b);
  }
}

/**
 * Reference to an item
 *
 * The uniqueness of an item is determined by the combination of:
 *
 *   * Type
 *   * UniqueAttributeValue
 *   * Scope
 *
 *
 * @generated from message Reference
 */
export class Reference extends Message<Reference> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: string uniqueAttributeValue = 2;
   */
  uniqueAttributeValue = "";

  /**
   * @generated from field: string scope = 3;
   */
  scope = "";

  /**
   * @generated from field: bool isQuery = 4;
   */
  isQuery = false;

  /**
   * @generated from field: string query = 5;
   */
  query = "";

  /**
   * @generated from field: QueryMethod method = 6;
   */
  method = QueryMethod.GET;

  constructor(data?: PartialMessage<Reference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Reference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "uniqueAttributeValue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "scope", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "isQuery", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "method", kind: "enum", T: proto3.getEnumType(QueryMethod) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Reference {
    return new Reference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Reference {
    return new Reference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Reference {
    return new Reference().fromJsonString(jsonString, options);
  }

  static equals(a: Reference | PlainMessage<Reference> | undefined, b: Reference | PlainMessage<Reference> | undefined): boolean {
    return proto3.util.equals(Reference, a, b);
  }
}

/**
 * Edge Represents a link between two items, it is not used in regular SDP
 * queries as it's up to the client to infer the edges from the LinkedItems
 * field, however request managed by the gateway will explicitly send edges to
 * reduce the processing burden on the client side
 *
 * @generated from message Edge
 */
export class Edge extends Message<Edge> {
  /**
   * @generated from field: Reference from = 1;
   */
  from?: Reference;

  /**
   * @generated from field: Reference to = 2;
   */
  to?: Reference;

  /**
   * @generated from field: BlastPropagation blastPropagation = 3;
   */
  blastPropagation?: BlastPropagation;

  constructor(data?: PartialMessage<Edge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Edge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from", kind: "message", T: Reference },
    { no: 2, name: "to", kind: "message", T: Reference },
    { no: 3, name: "blastPropagation", kind: "message", T: BlastPropagation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Edge {
    return new Edge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Edge {
    return new Edge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Edge {
    return new Edge().fromJsonString(jsonString, options);
  }

  static equals(a: Edge | PlainMessage<Edge> | undefined, b: Edge | PlainMessage<Edge> | undefined): boolean {
    return proto3.util.equals(Edge, a, b);
  }
}

